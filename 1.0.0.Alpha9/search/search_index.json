{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview SmallRye Stork SNAPSHOT is a service discovery and client-side load-balancing framework. The essence of distributed systems resides in the interaction between services . In modern architecture, you often have multiple instances of your service to share the load or improve the resilience by redundancy. But, how do you select the best instance of your service? That's where Stork helps. Stork is going to select the most appropriate instance. It offers: Extensible service discovery mechanisms Built-in support for Consul and Kubernetes Customizable client load-balancing strategies A programmatic API and a managed approach A Quarkus integration, but Stork can be used in any environment The problem In distributed systems, applications typically need to call one another. In a monolithic application, components invoke one another through language-level method or procedure calls. In a traditional distributed system deployment, services run at fixed, well-known locations (schemes, hosts, and ports) and can call one another using HTTP/REST or some RPC mechanism. The service locations are often hardcoded in the application configuration. Nevertheless, a modern distributed system or microservice-based application typically runs in virtualized or containerized environments where the number of instances of a service and their locations change dynamically. IPs get randomly assigned, and instances can be created or destroyed at any time. With such dynamics, hard-coded locations are a dead-end. The solution Stork handles the service lookup and selection. It proposes an extensible set of service discovery mechanisms and load-balancing strategies. What if the infrastructure provides such a feature? Some infrastructure, such as Kubernetes, provides service discoveries and load-balancing features. However, these mechanisms often lack flexibility. You cannot influence the service instance selection, and the load-balancing strategy is generally a simple round-robin . Stork provides more flexibility in the service instance selection. For example, it can select the fastest instance (based on the previous calls) to improve the response time. However, if you don't need that flexibility, just use the infrastructure layer.","title":"Overview"},{"location":"#overview","text":"SmallRye Stork SNAPSHOT is a service discovery and client-side load-balancing framework. The essence of distributed systems resides in the interaction between services . In modern architecture, you often have multiple instances of your service to share the load or improve the resilience by redundancy. But, how do you select the best instance of your service? That's where Stork helps. Stork is going to select the most appropriate instance. It offers: Extensible service discovery mechanisms Built-in support for Consul and Kubernetes Customizable client load-balancing strategies A programmatic API and a managed approach A Quarkus integration, but Stork can be used in any environment","title":"Overview"},{"location":"#the-problem","text":"In distributed systems, applications typically need to call one another. In a monolithic application, components invoke one another through language-level method or procedure calls. In a traditional distributed system deployment, services run at fixed, well-known locations (schemes, hosts, and ports) and can call one another using HTTP/REST or some RPC mechanism. The service locations are often hardcoded in the application configuration. Nevertheless, a modern distributed system or microservice-based application typically runs in virtualized or containerized environments where the number of instances of a service and their locations change dynamically. IPs get randomly assigned, and instances can be created or destroyed at any time. With such dynamics, hard-coded locations are a dead-end.","title":"The problem"},{"location":"#the-solution","text":"Stork handles the service lookup and selection. It proposes an extensible set of service discovery mechanisms and load-balancing strategies.","title":"The solution"},{"location":"#what-if-the-infrastructure-provides-such-a-feature","text":"Some infrastructure, such as Kubernetes, provides service discoveries and load-balancing features. However, these mechanisms often lack flexibility. You cannot influence the service instance selection, and the load-balancing strategy is generally a simple round-robin . Stork provides more flexibility in the service instance selection. For example, it can select the fastest instance (based on the previous calls) to improve the response time. However, if you don't need that flexibility, just use the infrastructure layer.","title":"What if the infrastructure provides such a feature?"},{"location":"concepts/","text":"Concepts This page presents the concepts used in Stork. When using Stork in a managed environment, such as Quarkus, all these concepts are hidden, as you only configure the lookup and selection. However, when using the programmatic API, you will use these concepts directly. Process overview When using the programmatic API of Stork, you: Retrieve the singleton Stork instance. This instance is configured with the set of Service it manages. Retrieve the Service you want to use. Each Service is associated with a name. Retrieve the ServiceInstance which will provide the metadata to access the actual service. Behind the scenes, Stork will handle the service lookup and selection. Note The service lookup and selection are asynchronous operations. Thus, the API returns instances of Uni . Stork io.smallrye.stork.Stork is the entry-point of the API. The Stork instance is a singleton . It needs to be initialized once (when the application starts) and shutdown when the application stops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package examples ; import io.smallrye.stork.Stork ; public class StorkEntryPointExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); // ... Stork . shutdown (); } } During the initialization, Stork looks for io.smallrye.stork.config.ConfigProvider SPI provider and retrieves the list of managed services: A service is identified by a name . A service has a service discovery configuration indicating how Stork will look for service instances A service can have a load-balancer configuration indicating how Stork can select the most appropriate instance. Service A io.smallrye.stork.Service is the structure representing a service used by the application. Services are pre-configured with their name, service discovery, and optionally, their load-balancer. You retrieve a Service using the Stork#getService(String name) method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.stork.Service ; import io.smallrye.stork.Stork ; public class StorkServiceExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); // ... Stork . shutdown (); } } The Service lets you retrieve the list of ServiceInstance , or select a single one, when a load-balancer is configured. Service Instance The io.smallrye.stork.ServiceInstance represents an actual instance of the service. It provides the metadata to configure a client to interact with that specific instance of service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package examples ; import io.smallrye.stork.Service ; import io.smallrye.stork.ServiceInstance ; import io.smallrye.stork.Stork ; import java.time.Duration ; import java.util.List ; public class StorkServiceLookupExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); List < ServiceInstance > instances = service . getServiceInstances () . await (). atMost ( Duration . ofSeconds ( 5 )); // ... Stork . shutdown (); } } The service selection is a two-steps process: Service lookup - using the service discovery Service selection - using the load balancer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package examples ; import io.smallrye.stork.Service ; import io.smallrye.stork.ServiceInstance ; import io.smallrye.stork.Stork ; import java.time.Duration ; public class StorkServiceSelectionExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); ServiceInstance instance = service . selectServiceInstance () . await (). atMost ( Duration . ofSeconds ( 5 )); System . out . println ( instance . getHost () + \":\" + instance . getPort ()); // ... Stork . shutdown (); } } Service Discovery The io.smallrye.stork.ServiceDiscovery represents a service discovery mechanism, such as DNS, Consul, or Eureka. You can implement a custom service discovery for Stork by implementing the ServiceDiscoveryProvider interface and register it with the Service Provider Interface (SPI) mechanism. Please note that the ServiceDiscovery implementation must be non-blocking. Load Balancer The io.smallrye.stork.LoadBalancer represents a load-balancer strategy, such as round-robin. To implement a custom load balancer for Stork, implement the LoadBalancerProvider interface and register it with the Service Provider Interface (SPI) mechanism. Please note that the LoadBalancer implementation, similarly to ServiceDiscovery must be non-blocking.","title":"Concepts"},{"location":"concepts/#concepts","text":"This page presents the concepts used in Stork. When using Stork in a managed environment, such as Quarkus, all these concepts are hidden, as you only configure the lookup and selection. However, when using the programmatic API, you will use these concepts directly.","title":"Concepts"},{"location":"concepts/#process-overview","text":"When using the programmatic API of Stork, you: Retrieve the singleton Stork instance. This instance is configured with the set of Service it manages. Retrieve the Service you want to use. Each Service is associated with a name. Retrieve the ServiceInstance which will provide the metadata to access the actual service. Behind the scenes, Stork will handle the service lookup and selection. Note The service lookup and selection are asynchronous operations. Thus, the API returns instances of Uni .","title":"Process overview"},{"location":"concepts/#stork","text":"io.smallrye.stork.Stork is the entry-point of the API. The Stork instance is a singleton . It needs to be initialized once (when the application starts) and shutdown when the application stops: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 package examples ; import io.smallrye.stork.Stork ; public class StorkEntryPointExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); // ... Stork . shutdown (); } } During the initialization, Stork looks for io.smallrye.stork.config.ConfigProvider SPI provider and retrieves the list of managed services: A service is identified by a name . A service has a service discovery configuration indicating how Stork will look for service instances A service can have a load-balancer configuration indicating how Stork can select the most appropriate instance.","title":"Stork"},{"location":"concepts/#service","text":"A io.smallrye.stork.Service is the structure representing a service used by the application. Services are pre-configured with their name, service discovery, and optionally, their load-balancer. You retrieve a Service using the Stork#getService(String name) method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.stork.Service ; import io.smallrye.stork.Stork ; public class StorkServiceExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); // ... Stork . shutdown (); } } The Service lets you retrieve the list of ServiceInstance , or select a single one, when a load-balancer is configured.","title":"Service"},{"location":"concepts/#service-instance","text":"The io.smallrye.stork.ServiceInstance represents an actual instance of the service. It provides the metadata to configure a client to interact with that specific instance of service. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package examples ; import io.smallrye.stork.Service ; import io.smallrye.stork.ServiceInstance ; import io.smallrye.stork.Stork ; import java.time.Duration ; import java.util.List ; public class StorkServiceLookupExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); List < ServiceInstance > instances = service . getServiceInstances () . await (). atMost ( Duration . ofSeconds ( 5 )); // ... Stork . shutdown (); } } The service selection is a two-steps process: Service lookup - using the service discovery Service selection - using the load balancer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package examples ; import io.smallrye.stork.Service ; import io.smallrye.stork.ServiceInstance ; import io.smallrye.stork.Stork ; import java.time.Duration ; public class StorkServiceSelectionExample { public static void main ( String [] args ) { Stork . initialize (); Stork stork = Stork . getInstance (); Service service = stork . getService ( \"my-service\" ); ServiceInstance instance = service . selectServiceInstance () . await (). atMost ( Duration . ofSeconds ( 5 )); System . out . println ( instance . getHost () + \":\" + instance . getPort ()); // ... Stork . shutdown (); } }","title":"Service Instance"},{"location":"concepts/#service-discovery","text":"The io.smallrye.stork.ServiceDiscovery represents a service discovery mechanism, such as DNS, Consul, or Eureka. You can implement a custom service discovery for Stork by implementing the ServiceDiscoveryProvider interface and register it with the Service Provider Interface (SPI) mechanism. Please note that the ServiceDiscovery implementation must be non-blocking.","title":"Service Discovery"},{"location":"concepts/#load-balancer","text":"The io.smallrye.stork.LoadBalancer represents a load-balancer strategy, such as round-robin. To implement a custom load balancer for Stork, implement the LoadBalancerProvider interface and register it with the Service Provider Interface (SPI) mechanism. Please note that the LoadBalancer implementation, similarly to ServiceDiscovery must be non-blocking.","title":"Load Balancer"},{"location":"consul/","text":"Consul Service Discovery Consul is a distributed, highly available, and data center aware solution to connect and configure applications across dynamic, distributed infrastructure. It's often used as service discovery backend to register and locate the services composing your system. Consul makes it simple for services to register themselves and to discover other services via a DNS or HTTP interface. External services can be registered as well. This page explains how Stork can use Consul to handle the service discovery. Dependency First, you need to add the Stork Consul Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-service-discovery-consul </artifactId> <version> SNAPSHOT </version> </dependency> Configuration For each service expected to be registered in Consul, configure the lookup: stork.my-service.service-discovery = consul stork.my-service.service-discovery.consul-host = localhost stork.my-service.service-discovery.consul-port = 8500 Stork looks for the service with the given name ( my-service in the previous example). Supported attributes are the following: Attribute Mandatory Default Value Description consul-host No localhost The Consul host consul-port No 8500 The Consul port use-health-checks No false Whether to use health check","title":"Consul"},{"location":"consul/#consul-service-discovery","text":"Consul is a distributed, highly available, and data center aware solution to connect and configure applications across dynamic, distributed infrastructure. It's often used as service discovery backend to register and locate the services composing your system. Consul makes it simple for services to register themselves and to discover other services via a DNS or HTTP interface. External services can be registered as well. This page explains how Stork can use Consul to handle the service discovery.","title":"Consul Service Discovery"},{"location":"consul/#dependency","text":"First, you need to add the Stork Consul Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-service-discovery-consul </artifactId> <version> SNAPSHOT </version> </dependency>","title":"Dependency"},{"location":"consul/#configuration","text":"For each service expected to be registered in Consul, configure the lookup: stork.my-service.service-discovery = consul stork.my-service.service-discovery.consul-host = localhost stork.my-service.service-discovery.consul-port = 8500 Stork looks for the service with the given name ( my-service in the previous example). Supported attributes are the following: Attribute Mandatory Default Value Description consul-host No localhost The Consul host consul-port No 8500 The Consul port use-health-checks No false Whether to use health check","title":"Configuration"},{"location":"custom-load-balancer/","text":"Implement your own load balancer mechanism Stork is extensible, and you can implement your service selection (load-balancer) mechanism. Stork uses the SPI mechanism for loading implementations matching Load Balancer Provider interface Dependency To implement your Load Balancer Provider , make sure your project depends on: <dependency> <groupI> io.smallrye.stork </groupI> <artifactId> smallrye-stork-api </artifactId> <version> SNAPSHOT </version> </dependency> Implementing a load balancer provider Stork uses the SPI mechanism for loading implementations matching Load Balancer Provider interface during its initialization. As a consequence, a load balancer provider implementation will contain: The provider is a factory that creates an io.smallrye.stork.LoadBalancer instance for each configured service using this load balancer provider. A type identifies each provider. You will use that type in the configuration to reference the load-balancer provider you want for each service: stork.my-service.load-balancer = acme The first step consists of implementing the io.smallrye.stork.spi.LoadBalancerProvider interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package examples ; import io.smallrye.stork.LoadBalancer ; import io.smallrye.stork.ServiceDiscovery ; import io.smallrye.stork.config.LoadBalancerConfig ; import io.smallrye.stork.config.ServiceDiscoveryConfig ; import io.smallrye.stork.spi.LoadBalancerProvider ; import io.smallrye.stork.spi.ServiceDiscoveryProvider ; public class AcmeLoadBalancerProvider implements LoadBalancerProvider { @Override public String type () { return \"acme\" ; } @Override public LoadBalancer createLoadBalancer ( LoadBalancerConfig config , ServiceDiscovery serviceDiscovery ) { return new AcmeLoadBalancer ( config ); } } This implementation is straightforward. The type method returns the load balancer provider identifier. The createLoadBalancer method is the factory method. It receives the instance configuration (a map constructed from all stork.my-service.load-balancer.attr=value properties) Then, obviously, we need to implement the LoadBalancer interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package examples ; import io.smallrye.stork.LoadBalancer ; import io.smallrye.stork.ServiceInstance ; import io.smallrye.stork.config.LoadBalancerConfig ; import java.util.ArrayList ; import java.util.Collection ; import java.util.Random ; public class AcmeLoadBalancer implements LoadBalancer { private final Random random ; public AcmeLoadBalancer ( LoadBalancerConfig config ) { random = new Random (); } @Override public ServiceInstance selectServiceInstance ( Collection < ServiceInstance > serviceInstances ) { int index = random . nextInt ( serviceInstances . size ()); return new ArrayList <> ( serviceInstances ). get ( index ); } } Again, this implementation is simplistic and just picks a random instance from the received list. The final step is to declare our LoadBalancerProvider in the META-INF/services/io.smallrye.stork.spi.LoadBalancerProvider file: examples.AcmeLoadBalancerProvider Using your load balancer In the project using it, don't forget to add the dependency on the module providing your implementation. Then, in the configuration, just add: stork.my-service.service-discovery = ... stork.my-service.load-balancer = acme Then, Stork will use your implementation to select the my-service service instance.","title":"Custom"},{"location":"custom-load-balancer/#implement-your-own-load-balancer-mechanism","text":"Stork is extensible, and you can implement your service selection (load-balancer) mechanism. Stork uses the SPI mechanism for loading implementations matching Load Balancer Provider interface","title":"Implement your own load balancer mechanism"},{"location":"custom-load-balancer/#dependency","text":"To implement your Load Balancer Provider , make sure your project depends on: <dependency> <groupI> io.smallrye.stork </groupI> <artifactId> smallrye-stork-api </artifactId> <version> SNAPSHOT </version> </dependency>","title":"Dependency"},{"location":"custom-load-balancer/#implementing-a-load-balancer-provider","text":"Stork uses the SPI mechanism for loading implementations matching Load Balancer Provider interface during its initialization. As a consequence, a load balancer provider implementation will contain: The provider is a factory that creates an io.smallrye.stork.LoadBalancer instance for each configured service using this load balancer provider. A type identifies each provider. You will use that type in the configuration to reference the load-balancer provider you want for each service: stork.my-service.load-balancer = acme The first step consists of implementing the io.smallrye.stork.spi.LoadBalancerProvider interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package examples ; import io.smallrye.stork.LoadBalancer ; import io.smallrye.stork.ServiceDiscovery ; import io.smallrye.stork.config.LoadBalancerConfig ; import io.smallrye.stork.config.ServiceDiscoveryConfig ; import io.smallrye.stork.spi.LoadBalancerProvider ; import io.smallrye.stork.spi.ServiceDiscoveryProvider ; public class AcmeLoadBalancerProvider implements LoadBalancerProvider { @Override public String type () { return \"acme\" ; } @Override public LoadBalancer createLoadBalancer ( LoadBalancerConfig config , ServiceDiscovery serviceDiscovery ) { return new AcmeLoadBalancer ( config ); } } This implementation is straightforward. The type method returns the load balancer provider identifier. The createLoadBalancer method is the factory method. It receives the instance configuration (a map constructed from all stork.my-service.load-balancer.attr=value properties) Then, obviously, we need to implement the LoadBalancer interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package examples ; import io.smallrye.stork.LoadBalancer ; import io.smallrye.stork.ServiceInstance ; import io.smallrye.stork.config.LoadBalancerConfig ; import java.util.ArrayList ; import java.util.Collection ; import java.util.Random ; public class AcmeLoadBalancer implements LoadBalancer { private final Random random ; public AcmeLoadBalancer ( LoadBalancerConfig config ) { random = new Random (); } @Override public ServiceInstance selectServiceInstance ( Collection < ServiceInstance > serviceInstances ) { int index = random . nextInt ( serviceInstances . size ()); return new ArrayList <> ( serviceInstances ). get ( index ); } } Again, this implementation is simplistic and just picks a random instance from the received list. The final step is to declare our LoadBalancerProvider in the META-INF/services/io.smallrye.stork.spi.LoadBalancerProvider file: examples.AcmeLoadBalancerProvider","title":"Implementing a load balancer provider"},{"location":"custom-load-balancer/#using-your-load-balancer","text":"In the project using it, don't forget to add the dependency on the module providing your implementation. Then, in the configuration, just add: stork.my-service.service-discovery = ... stork.my-service.load-balancer = acme Then, Stork will use your implementation to select the my-service service instance.","title":"Using your load balancer"},{"location":"custom-service-discovery/","text":"Implement your own service discovery mechanism Stork is extensible, and you can implement your own service discovery mechanism. Stork uses the SPI mechanism for loading implementations matching Service Discovery Provider interface. Dependency To implement your Service Discovery Provider , make sure your project depends on: <dependency> <groupI> io.smallrye.stork </groupI> <artifactId> smallrye-stork-api </artifactId> <version> SNAPSHOT </version> </dependency> Implementing a service discovery provider Stork uses the SPI mechanism for loading implementations matching Service Discovery Provider interface during its initialization.As a consequence, a service discovery provider implementation will contain: The provider is a factory that creates an io.smallrye.stork.ServiceDiscovery instance for each configured service using this service discovery provider. A type , for example, acme , identifies each provider. This type is used in the configuration to reference the provider: stork.my-service.service-discovery = acme The first step consists of implementing the io.smallrye.stork.spi.ServiceDiscoveryProvider interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.stork.ServiceDiscovery ; import io.smallrye.stork.config.ServiceDiscoveryConfig ; import io.smallrye.stork.spi.ServiceDiscoveryProvider ; public class AcmeServiceDiscoveryProvider implements ServiceDiscoveryProvider { @Override public String type () { return \"acme\" ; } @Override public ServiceDiscovery createServiceDiscovery ( ServiceDiscoveryConfig config , String serviceName ) { return new AcmeServiceDiscovery ( config . parameters ()); } } This implementation is straightforward. The type method returns the service discovery provider identifier. The createServiceDiscovery method is the factory method. It receives the instance configuration (a map constructed from all stork.my-service.service-discovery.attr=value properties) Then, obviously, we need to implement the ServiceDiscovery interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package examples ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.DefaultServiceInstance ; import io.smallrye.stork.ServiceDiscovery ; import io.smallrye.stork.ServiceInstance ; import io.smallrye.stork.spi.ServiceInstanceIds ; import java.util.Collections ; import java.util.List ; import java.util.Map ; public class AcmeServiceDiscovery implements ServiceDiscovery { private final String host ; private final int port ; public AcmeServiceDiscovery ( Map < String , String > configuration ) { this . host = configuration . get ( \"host\" ); this . port = Integer . parseInt ( configuration . get ( \"port\" )); } @Override public Uni < List < ServiceInstance >> getServiceInstances () { // Proceed to the lookup... // Here, we just return a DefaultServiceInstance with the configured host and port DefaultServiceInstance instance = new DefaultServiceInstance ( ServiceInstanceIds . next (), host , port ); return Uni . createFrom (). item (() -> Collections . singletonList ( instance )); } } Again, this implementation is simplistic. Typically, instead of creating a service instance with values from the configuration, you would connect to a service discovery backend, look for the service and build the list of service instance accordingly. That's why the method returns a Uni . Most of the time, the lookup is a remote operation. The final step is to declare our ServiceDiscoveryProvider in the META-INF/services/io.smallrye.stork.spi.ServiceDiscoveryProvider file: examples.AcmeServiceDiscoveryProvider Using your service discovery In the project using it, don't forget to add the dependency on the module providing your implementation. Then, in the configuration, just add: stork.my-service.service-discovery = acme stork.my-service.service-discovery.host = localhost stork.my-service.service-discovery.port = 1234 Then, Stork will use your implementation to locate the my-service service.","title":"Custom"},{"location":"custom-service-discovery/#implement-your-own-service-discovery-mechanism","text":"Stork is extensible, and you can implement your own service discovery mechanism. Stork uses the SPI mechanism for loading implementations matching Service Discovery Provider interface.","title":"Implement your own service discovery mechanism"},{"location":"custom-service-discovery/#dependency","text":"To implement your Service Discovery Provider , make sure your project depends on: <dependency> <groupI> io.smallrye.stork </groupI> <artifactId> smallrye-stork-api </artifactId> <version> SNAPSHOT </version> </dependency>","title":"Dependency"},{"location":"custom-service-discovery/#implementing-a-service-discovery-provider","text":"Stork uses the SPI mechanism for loading implementations matching Service Discovery Provider interface during its initialization.As a consequence, a service discovery provider implementation will contain: The provider is a factory that creates an io.smallrye.stork.ServiceDiscovery instance for each configured service using this service discovery provider. A type , for example, acme , identifies each provider. This type is used in the configuration to reference the provider: stork.my-service.service-discovery = acme The first step consists of implementing the io.smallrye.stork.spi.ServiceDiscoveryProvider interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import io.smallrye.stork.ServiceDiscovery ; import io.smallrye.stork.config.ServiceDiscoveryConfig ; import io.smallrye.stork.spi.ServiceDiscoveryProvider ; public class AcmeServiceDiscoveryProvider implements ServiceDiscoveryProvider { @Override public String type () { return \"acme\" ; } @Override public ServiceDiscovery createServiceDiscovery ( ServiceDiscoveryConfig config , String serviceName ) { return new AcmeServiceDiscovery ( config . parameters ()); } } This implementation is straightforward. The type method returns the service discovery provider identifier. The createServiceDiscovery method is the factory method. It receives the instance configuration (a map constructed from all stork.my-service.service-discovery.attr=value properties) Then, obviously, we need to implement the ServiceDiscovery interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package examples ; import io.smallrye.mutiny.Uni ; import io.smallrye.stork.DefaultServiceInstance ; import io.smallrye.stork.ServiceDiscovery ; import io.smallrye.stork.ServiceInstance ; import io.smallrye.stork.spi.ServiceInstanceIds ; import java.util.Collections ; import java.util.List ; import java.util.Map ; public class AcmeServiceDiscovery implements ServiceDiscovery { private final String host ; private final int port ; public AcmeServiceDiscovery ( Map < String , String > configuration ) { this . host = configuration . get ( \"host\" ); this . port = Integer . parseInt ( configuration . get ( \"port\" )); } @Override public Uni < List < ServiceInstance >> getServiceInstances () { // Proceed to the lookup... // Here, we just return a DefaultServiceInstance with the configured host and port DefaultServiceInstance instance = new DefaultServiceInstance ( ServiceInstanceIds . next (), host , port ); return Uni . createFrom (). item (() -> Collections . singletonList ( instance )); } } Again, this implementation is simplistic. Typically, instead of creating a service instance with values from the configuration, you would connect to a service discovery backend, look for the service and build the list of service instance accordingly. That's why the method returns a Uni . Most of the time, the lookup is a remote operation. The final step is to declare our ServiceDiscoveryProvider in the META-INF/services/io.smallrye.stork.spi.ServiceDiscoveryProvider file: examples.AcmeServiceDiscoveryProvider","title":"Implementing a service discovery provider"},{"location":"custom-service-discovery/#using-your-service-discovery","text":"In the project using it, don't forget to add the dependency on the module providing your implementation. Then, in the configuration, just add: stork.my-service.service-discovery = acme stork.my-service.service-discovery.host = localhost stork.my-service.service-discovery.port = 1234 Then, Stork will use your implementation to locate the my-service service.","title":"Using your service discovery"},{"location":"eureka/","text":"Eureka Service Discovery Eureka is a RESTful service that is primarily used in the AWS cloud for the purpose of discovery, load balancing, and failover of middle-tier servers. This page explains how Stork can use Eureka to handle the service discovery. Dependency First, you need to add the Stork Consul Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-service-discovery-eureka </artifactId> <version> SNAPSHOT </version> </dependency> Configuration For each application instance expected to be registered in Eureka, configure the lookup: stork.my-service.service-discovery = eureka stork.my-service.service-discovery.eureka-host = localhost stork.my-service.service-discovery.eureka-port = 8761 Stork looks for the service with the given name ( my-service in the previous example). Supported attributes are the following: Attribute Mandatory Default Value Description eureka-host Yes The Eureka server host eureka-port No 8761 The Eureka server port eureka-trust-all No false Enable/Disable the TLS certificate verification eureka-ssl No false Use TLS to connect to the Eureka server application No the service name The Eureka application Id instance No The Eureka application instance Id secure No false Whether it should select the secure virtual address The application attribute is optional. It uses the Stork service name ( my-service in the previous configuration) if not set. The instance attribute allows selecting a specific instance. Using this attribute prevents load-balancing as you will always select a single instance. The secure attribute indicates if you want the secure virtual address of the application instance. If set to true , unsecured instances are filtered out from the available instances.","title":"Eureka"},{"location":"eureka/#eureka-service-discovery","text":"Eureka is a RESTful service that is primarily used in the AWS cloud for the purpose of discovery, load balancing, and failover of middle-tier servers. This page explains how Stork can use Eureka to handle the service discovery.","title":"Eureka Service Discovery"},{"location":"eureka/#dependency","text":"First, you need to add the Stork Consul Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-service-discovery-eureka </artifactId> <version> SNAPSHOT </version> </dependency>","title":"Dependency"},{"location":"eureka/#configuration","text":"For each application instance expected to be registered in Eureka, configure the lookup: stork.my-service.service-discovery = eureka stork.my-service.service-discovery.eureka-host = localhost stork.my-service.service-discovery.eureka-port = 8761 Stork looks for the service with the given name ( my-service in the previous example). Supported attributes are the following: Attribute Mandatory Default Value Description eureka-host Yes The Eureka server host eureka-port No 8761 The Eureka server port eureka-trust-all No false Enable/Disable the TLS certificate verification eureka-ssl No false Use TLS to connect to the Eureka server application No the service name The Eureka application Id instance No The Eureka application instance Id secure No false Whether it should select the secure virtual address The application attribute is optional. It uses the Stork service name ( my-service in the previous configuration) if not set. The instance attribute allows selecting a specific instance. Using this attribute prevents load-balancing as you will always select a single instance. The secure attribute indicates if you want the secure virtual address of the application instance. If set to true , unsecured instances are filtered out from the available instances.","title":"Configuration"},{"location":"kubernetes/","text":"Kubernetes Service Discovery Kubernetes has a built-in support for service discovery and load-balancing. However, you may need more flexibility to carefully select the service instance you want. This page explains how Stork can use the Kubernetes API to handle the service discovery. Dependency First, you need to add the Stork Kubernetes Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-service-discovery-kubernetes </artifactId> <version> SNAPSHOT </version> </dependency> Configuration For each service expected to be exposed as Kubernetes Service , configure the lookup: stork.my-service.service-discovery = kubernetes stork.my-service.service-discovery.k8s-namespace = my-namespace Stork looks for the Kubernetes Service with the given name ( my-service in the previous example) in the specified namespace. Instead of using the Kubernetes Service IP directly, and let Kubernetes handle the selection and balancing, Stork inspects the service and retrieves the list of pods providing the service. Then, it can select the instance. Supported attributes are the following: Attribute Mandatory Default Value Description k8s-host No master url The Kubernetes API host k8s-namespace No The namespace of the service. Use all to discover all namespaces.","title":"Kubernetes"},{"location":"kubernetes/#kubernetes-service-discovery","text":"Kubernetes has a built-in support for service discovery and load-balancing. However, you may need more flexibility to carefully select the service instance you want. This page explains how Stork can use the Kubernetes API to handle the service discovery.","title":"Kubernetes Service Discovery"},{"location":"kubernetes/#dependency","text":"First, you need to add the Stork Kubernetes Service Discovery provider: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-service-discovery-kubernetes </artifactId> <version> SNAPSHOT </version> </dependency>","title":"Dependency"},{"location":"kubernetes/#configuration","text":"For each service expected to be exposed as Kubernetes Service , configure the lookup: stork.my-service.service-discovery = kubernetes stork.my-service.service-discovery.k8s-namespace = my-namespace Stork looks for the Kubernetes Service with the given name ( my-service in the previous example) in the specified namespace. Instead of using the Kubernetes Service IP directly, and let Kubernetes handle the selection and balancing, Stork inspects the service and retrieves the list of pods providing the service. Then, it can select the instance. Supported attributes are the following: Attribute Mandatory Default Value Description k8s-host No master url The Kubernetes API host k8s-namespace No The namespace of the service. Use all to discover all namespaces.","title":"Configuration"},{"location":"quarkus/","text":"Using Stork with Quarkus Quarkus is a Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM. Quarkus REST Client Reactive and gRPC extensions come with built-in integration with SmallRye Stork. This page describes how to use REST Client Reactive with Stork. Using gRPC with Stork is similar. We will use the Consul service discovery and the round-robin load balancer as examples. The project You can create a Quarkus project with the REST Client Reactive extension using code.quarkus.io . The corresponding Quarkus guide describes the extension in more detail. The client To use the REST client to communicate with a remote endpoint, you need to create an interface that describes how the communication should work. The client requires baseUri (or baseUrl ) pointing to the address of the remote endpoint. To use Stork to determine the actual address, set the scheme of the URI to stork and the hostname of the URI to the name of the Stork service. For example, the HelloClient below will use the Stork service called hello-service to determine the address of the destination, and /hello as the base path for queries: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import org.eclipse.microprofile.rest.client.inject.RegisterRestClient ; import javax.ws.rs.Consumes ; import javax.ws.rs.POST ; import javax.ws.rs.Path ; import javax.ws.rs.Produces ; import javax.ws.rs.core.MediaType ; @Path ( \"/\" ) @RegisterRestClient ( baseUri = \"stork://hello-service/hello\" ) public interface HelloClient { @POST @Produces ( MediaType . TEXT_PLAIN ) @Consumes ( MediaType . TEXT_PLAIN ) String echo ( String name ); } The service In Stork, a Service consists of service discovery and a load balancer. The Service discovery is responsible for determining the ServiceInstance s, that is, available addresses for a service. The load balancer picks a single ServiceInstance for a call. Dependencies To use the service discovery and the load balancer of your choosing, you need to add the appropriate dependencies to your application. For example, if you wish to use Consul and load-balance the calls with round-robin, add the following to your pom.xml : <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-service-discovery-consul </artifactId> <version> SNAPSHOT </version> </dependency> <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-load-balancer-round-robin </artifactId> <version> SNAPSHOT </version> </dependency> When using Eureka, Kubernetes, or any other service discovery mechanism, or a different load balancer, replace the dependencies above with the ones you need. Based on the defined dependencies, Stork automatically registers providers for service discovery mechanisms and load balancers. The config The last piece of the puzzle is the actual service configuration. If your Consul instance is running on localhost on port 8500 , service discovery configuration should look as follows: stork.hello-service.service-discovery = consul stork.hello-service.service-discovery.consul-host = localhost stork.hello-service.service-discovery.consul-port = 8500 For the round-robin load balancer, the config should just define the load balancer type: stork.hello-service.load-balancer = round-robin","title":"Using Stork with Quarkus"},{"location":"quarkus/#using-stork-with-quarkus","text":"Quarkus is a Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM. Quarkus REST Client Reactive and gRPC extensions come with built-in integration with SmallRye Stork. This page describes how to use REST Client Reactive with Stork. Using gRPC with Stork is similar. We will use the Consul service discovery and the round-robin load balancer as examples.","title":"Using Stork with Quarkus"},{"location":"quarkus/#the-project","text":"You can create a Quarkus project with the REST Client Reactive extension using code.quarkus.io . The corresponding Quarkus guide describes the extension in more detail.","title":"The project"},{"location":"quarkus/#the-client","text":"To use the REST client to communicate with a remote endpoint, you need to create an interface that describes how the communication should work. The client requires baseUri (or baseUrl ) pointing to the address of the remote endpoint. To use Stork to determine the actual address, set the scheme of the URI to stork and the hostname of the URI to the name of the Stork service. For example, the HelloClient below will use the Stork service called hello-service to determine the address of the destination, and /hello as the base path for queries: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package examples ; import org.eclipse.microprofile.rest.client.inject.RegisterRestClient ; import javax.ws.rs.Consumes ; import javax.ws.rs.POST ; import javax.ws.rs.Path ; import javax.ws.rs.Produces ; import javax.ws.rs.core.MediaType ; @Path ( \"/\" ) @RegisterRestClient ( baseUri = \"stork://hello-service/hello\" ) public interface HelloClient { @POST @Produces ( MediaType . TEXT_PLAIN ) @Consumes ( MediaType . TEXT_PLAIN ) String echo ( String name ); }","title":"The client"},{"location":"quarkus/#the-service","text":"In Stork, a Service consists of service discovery and a load balancer. The Service discovery is responsible for determining the ServiceInstance s, that is, available addresses for a service. The load balancer picks a single ServiceInstance for a call.","title":"The service"},{"location":"quarkus/#dependencies","text":"To use the service discovery and the load balancer of your choosing, you need to add the appropriate dependencies to your application. For example, if you wish to use Consul and load-balance the calls with round-robin, add the following to your pom.xml : <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-service-discovery-consul </artifactId> <version> SNAPSHOT </version> </dependency> <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-load-balancer-round-robin </artifactId> <version> SNAPSHOT </version> </dependency> When using Eureka, Kubernetes, or any other service discovery mechanism, or a different load balancer, replace the dependencies above with the ones you need. Based on the defined dependencies, Stork automatically registers providers for service discovery mechanisms and load balancers.","title":"Dependencies"},{"location":"quarkus/#the-config","text":"The last piece of the puzzle is the actual service configuration. If your Consul instance is running on localhost on port 8500 , service discovery configuration should look as follows: stork.hello-service.service-discovery = consul stork.hello-service.service-discovery.consul-host = localhost stork.hello-service.service-discovery.consul-port = 8500 For the round-robin load balancer, the config should just define the load balancer type: stork.hello-service.load-balancer = round-robin","title":"The config"},{"location":"response-time/","text":"Least Response Time Load Balancing The least-response-time load balancing strategy monitors the operations and selects the fastest instance. This load balancer collects statistics and determines which instance will provide the shorter response time. Dependency First, you need to add the least-response-time load-balancer to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-load-balancer-response-time </artifactId> <version> SNAPSHOT </version> </dependency> Configuration For each service expected to use a least-response-time selection, configure the load-balancer to be least-response-time : stork.my-service.service-discovery = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer = least-response-time","title":"Response Time"},{"location":"response-time/#least-response-time-load-balancing","text":"The least-response-time load balancing strategy monitors the operations and selects the fastest instance. This load balancer collects statistics and determines which instance will provide the shorter response time.","title":"Least Response Time Load Balancing"},{"location":"response-time/#dependency","text":"First, you need to add the least-response-time load-balancer to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-load-balancer-response-time </artifactId> <version> SNAPSHOT </version> </dependency>","title":"Dependency"},{"location":"response-time/#configuration","text":"For each service expected to use a least-response-time selection, configure the load-balancer to be least-response-time : stork.my-service.service-discovery = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer = least-response-time","title":"Configuration"},{"location":"round-robin/","text":"Round-Robin Load Balancing The round-robin is a straightforward load-balancing solution that just iterates over the set of service instances. While being simple, this solution shares the load among the instances and may be sufficient in many cases. Dependency First, you need to add the round-robin load-balancer to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-load-balancer-round-robin </artifactId> <version> SNAPSHOT </version> </dependency> Configuration For each service expected to use a round-robin selection, configure the load-balancer to be round-robin : stork.my-service.service-discovery = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer = round-robin","title":"Round Robin"},{"location":"round-robin/#round-robin-load-balancing","text":"The round-robin is a straightforward load-balancing solution that just iterates over the set of service instances. While being simple, this solution shares the load among the instances and may be sufficient in many cases.","title":"Round-Robin Load Balancing"},{"location":"round-robin/#dependency","text":"First, you need to add the round-robin load-balancer to your project: <dependency> <groupId> io.smallrye.stork </groupId> <artifactId> smallrye-stork-load-balancer-round-robin </artifactId> <version> SNAPSHOT </version> </dependency>","title":"Dependency"},{"location":"round-robin/#configuration","text":"For each service expected to use a round-robin selection, configure the load-balancer to be round-robin : stork.my-service.service-discovery = ... stork.my-service.service-discovery... = ... stork.my-service.load-balancer = round-robin","title":"Configuration"}]}