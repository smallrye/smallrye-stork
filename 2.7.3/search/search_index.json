{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>SmallRye Stork <code>2.7.3</code> is a service discovery and client-side load-balancing framework.</p> <p>The essence of distributed systems resides in the interaction between services. In modern architecture, you often have multiple instances of your service to share the load or improve the resilience by redundancy. But, how do you select the best instance of your service? That\u2019s where Stork helps. Stork is going to select the most appropriate instance. It offers:</p> <ul> <li>Extensible service discovery mechanisms</li> <li>Built-in support for Consul and Kubernetes</li> <li>Customizable client load-balancing strategies</li> <li>A programmatic API and a managed approach</li> <li>A Quarkus integration, but Stork can be used in any environment</li> </ul>"},{"location":"#the-problem","title":"The problem","text":"<p>In distributed systems, applications typically need to call one another. In a monolithic application, components invoke one another through language-level method or procedure calls. In a traditional distributed system deployment, services run at fixed, well-known locations (schemes, hosts, and ports) and can call one another using HTTP/REST or some RPC mechanism. The service locations are often hardcoded in the application configuration. Nevertheless, a modern distributed system or microservice-based application typically runs in virtualized or containerized environments where the number of instances of a service and their locations change dynamically. IPs get randomly assigned, and instances can be created or destroyed at any time. With such dynamics, hard-coded locations are a dead-end.</p> <p> </p>"},{"location":"#the-solution","title":"The solution","text":"<p>Stork handles the service lookup and selection. It proposes an extensible set of service discovery mechanisms and load-balancing strategies.</p> <p> </p>"},{"location":"#what-if-the-infrastructure-provides-such-a-feature","title":"What if the infrastructure provides such a feature?","text":"<p>Some infrastructure, such as Kubernetes, provides service discoveries and load-balancing features. However, these mechanisms often lack flexibility. You cannot influence the service instance selection, and the load-balancing strategy is generally a simple round-robin.</p> <p>Stork provides more flexibility in the service instance selection. For example, it can select the fastest instance (based on the previous calls) to improve the response time. However, if you don\u2019t need that flexibility, just use the infrastructure layer.</p>"},{"location":"concepts/","title":"Concepts","text":"<p>This page presents the concepts used in Stork. When using Stork in a managed environment, such as Quarkus, all these concepts are hidden, as you only configure the lookup and selection. However, when using the programmatic API, you will use these concepts directly.</p> <p> </p>"},{"location":"concepts/#process-overview","title":"Process overview","text":"<p>When using the programmatic API of Stork, you can:</p> <ol> <li>Retrieve the singleton <code>Stork</code> instance. This instance is configured with the set of <code>Service</code> it manages.</li> <li>Retrieve the <code>Service</code> you want to use. Each <code>Service</code> is associated with a name.</li> <li>Retrieve the <code>ServiceInstance</code> which will provide the metadata to access the actual service.</li> </ol> <p> </p> <p>Behind the scenes, Stork will handle the service lookup and selection.</p> <p>Note</p> <p>The service lookup and selection are asynchronous operations. Thus, the API returns instances of <code>Uni</code>. </p>"},{"location":"concepts/#stork","title":"Stork","text":"<p><code>io.smallrye.stork.Stork</code> is the entry-point of the API. The <code>Stork</code> instance is a singleton. It needs to be initialized once (when the application starts) and shutdown when the application stops:</p> <pre><code>package examples;\n\nimport io.smallrye.stork.Stork;\n\npublic class StorkEntryPointExample {\n\n    public static void main(String[] args) {\n        Stork.initialize();\n        Stork stork = Stork.getInstance();\n        // ...\n        Stork.shutdown();\n    }\n\n}\n</code></pre> <p>During the initialization, Stork looks for <code>io.smallrye.stork.config.ConfigProvider</code> SPI provider and CDI beans (from 2.x version) and retrieves the list of managed services:</p> <ul> <li>A service is identified by a name. </li> <li>A service has a service discovery configuration indicating how Stork will look for service instances</li> <li>A service can have a load-balancer configuration indicating how Stork can select the most appropriate instance.</li> </ul>"},{"location":"concepts/#service","title":"Service","text":"<p>A <code>io.smallrye.stork.Service</code> is the structure representing a service used by the application. Services are pre-configured with their name, service discovery, and optionally, their load-balancer. You retrieve a <code>Service</code> using the <code>Stork#getService(String name)</code> method.</p> <pre><code>package examples;\n\nimport io.smallrye.stork.api.Service;\nimport io.smallrye.stork.Stork;\n\npublic class StorkServiceExample {\n\n    public static void main(String[] args) {\n        Stork.initialize();\n        Stork stork = Stork.getInstance();\n\n        Service service = stork.getService(\"my-service\");\n\n        // ...\n        Stork.shutdown();\n    }\n\n}\n</code></pre> <p>The <code>Service</code> lets you retrieve the list of <code>ServiceInstance</code>, or select a single one, when a load-balancer is configured.</p>"},{"location":"concepts/#service-instance","title":"Service Instance","text":"<p>The <code>io.smallrye.stork.api.ServiceInstance</code> represents an actual instance of the service.  It provides the metadata to configure a client to interact with that specific instance of service.</p> <pre><code>package examples;\n\nimport java.time.Duration;\nimport java.util.List;\n\nimport io.smallrye.stork.Stork;\nimport io.smallrye.stork.api.Service;\nimport io.smallrye.stork.api.ServiceInstance;\n\npublic class StorkServiceLookupExample {\n\n    public static void main(String[] args) {\n        Stork.initialize();\n        Stork stork = Stork.getInstance();\n\n        Service service = stork.getService(\"my-service\");\n        List&lt;ServiceInstance&gt; instances = service.getInstances()\n                .await().atMost(Duration.ofSeconds(5));\n\n        // ...\n        Stork.shutdown();\n    }\n\n}\n</code></pre> <p>The service selection is a two-steps process:</p> <ol> <li>Service lookup - using the service discovery</li> <li>Service selection - using the load balancer</li> </ol> <pre><code>package examples;\n\nimport java.time.Duration;\n\nimport io.smallrye.stork.Stork;\nimport io.smallrye.stork.api.Service;\nimport io.smallrye.stork.api.ServiceInstance;\n\npublic class StorkServiceSelectionExample {\n\n    public static void main(String[] args) {\n        Stork.initialize();\n        Stork stork = Stork.getInstance();\n\n        Service service = stork.getService(\"my-service\");\n        ServiceInstance instance = service.selectInstance()\n                .await().atMost(Duration.ofSeconds(5));\n\n        System.out.println(instance.getHost() + \":\" + instance.getPort());\n\n        // ...\n        Stork.shutdown();\n    }\n\n}\n</code></pre>"},{"location":"concepts/#service-discovery","title":"Service Discovery","text":"<p>The <code>io.smallrye.stork.api.ServiceDiscovery</code> represents a service discovery mechanism, such as DNS, Consul, or Eureka.</p> <p>You can implement a custom service discovery for Stork by implementing the <code>ServiceDiscoveryProvider</code> interface. The corresponding <code>ServiceRegistrarProviderLoader</code> and <code>RegistrarConfiguration</code> classes will be automatically generated during compilation time.</p> <p>Please note that the <code>ServiceDiscovery</code> implementation must be non-blocking.</p>"},{"location":"concepts/#load-balancer","title":"Load Balancer","text":"<p>The <code>io.smallrye.stork.api.LoadBalancer</code> represents a load-balancer strategy, such as round-robin.</p> <p>To implement a custom load balancer for Stork, implement the <code>LoadBalancerProvider</code> interface. The corresponding <code>LoadBalancerProviderLoader</code> and <code>Configuration</code> classes will be automatically generated during compilation time.</p> <p>Please note that the <code>LoadBalancer</code> implementation, similarly to <code>ServiceDiscovery</code> must be non-blocking.</p>"},{"location":"concepts/#service-registration","title":"Service registration","text":"<p>The <code>io.smallrye.stork.api.ServiceRegistrar</code> represents a service registration mechanism for Consul and Eureka.</p> <p>You can implement a custom service registrar for Stork by implementing the <code>ServiceRegistrarProvider</code> interface. The corresponding <code>ServiceRegistrarProviderLoader</code> and <code>RegistrarConfiguration</code> classes will be automatically generated during compilation time. </p> <p>Please note that the <code>ServiceRegistrar</code> implementation must be non-blocking.</p>"},{"location":"microprofile-config/","title":"Stork MicroProfile Config","text":"<p>Stork integrates with MicroProfile Configuration out of the box, enabling seamless access to configuration properties.  This documentation explains how Stork can retrieve configuration details from the MicroProfile Config file present in the classpath. Quarkus uses this approach for reading configuration details from the MicroProfile Config file located within the classpath.</p>"},{"location":"microprofile-config/#dependency-setup","title":"Dependency setup","text":"<p>To enable MicroProfile Config integration in Stork, you need to include the following dependency:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;smallrye-stork-microprofile&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"microprofile-config/#initializing-stork","title":"Initializing Stork","text":"<p>If your framework lacks a pre-configured Stork instance, you\u2019ll need to perform initialization:</p> <p><pre><code>package examples;\n\nimport io.smallrye.stork.Stork;\nimport io.smallrye.stork.api.ServiceDefinition;\nimport io.smallrye.stork.api.ServiceInstance;\nimport io.smallrye.stork.loadbalancer.random.RandomConfiguration;\nimport io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration;\n\nimport java.time.Duration;\n\npublic class InitializationExample {\n\n    public static void main(String[] args) {\n        Stork.initialize();\n        Stork stork = Stork.getInstance();\n        // ...\n    }\n}\n</code></pre> Upon initialization, Stork scans for the <code>io.smallrye.stork.config.MicroProfileConfigProvider</code> SPI provider and CDI beans (from version 2.x onwards). It then builds a comprehensive list of managed services by parsing the properties configuration files.</p>"},{"location":"observability/","title":"Stork Observability API","text":"<p>Stork proposes an observability API that automatically observes some parameters to show how the Stork service discovery and selection are behaving.</p> <p>For any observation to happen, you need to provide your own implementation of an <code>ObservationCollector.</code> By default, Stork provides a no-op implementation.</p> <p>The <code>ObservationCollector</code> is responsible for instantiating the <code>StorkObservation</code>.</p> <p>The <code>StorkObservation</code> reacts to Stork events thanks to a <code>StorkEventHandler</code>. </p> <p>You can extend the metrics collection by extending the <code>StorkEventHandler</code> interface.</p> <p>The following sequence diagram shows how the observability is initialized : </p> <p> </p> <p>The <code>StorkObservation</code> registers times, number of discovered instances, the selected instance and failures by reacting to the lifecycle of a Stork event such as:</p> <ul> <li>start : Observation has been started.  The beginning time is registered.  It happens when the <code>ObservationCollector#create()</code> method gets called.</li> <li>service discovery success: a collection of instances has been successfully discovered for a service.  The end discovery time and number of instances are recorded.  It happens when the <code>StorkObservation#onServiceDiscoverySuccess</code> gets called.</li> <li>service discovery error: an error occurs when discovering a service.  The end discovery time and failure cause are captured.  It happens when the <code>StorkObservation#onServiceDiscoveryFailure</code> gets called.</li> <li>service selection success: an instance has been successfully selected from the collection. The end selection time and selected instance ID are registered. It happens when the <code>StorkObservation#onServiceSelectionSuccess</code> gets called.</li> <li>service selection error: an error occurred during selecting the instance.  End selection time and failure cause are registered.  It happens when the <code>StorkObservation#onServiceSelectionFailure</code> gets called.</li> <li>end: Observation has finished. Overall duration is registered.  It happens when the <code>StorkObservation#onServiceSelectionSuccess</code> gets called.</li> </ul> <p>The following sequence diagram represents the described observation process above:</p> <p> </p>"},{"location":"observability/#implementing-an-observation-collector","title":"Implementing an observation collector","text":"<p>An <code>ObservationCollector</code> implementation must override the <code>create</code> method to provide an instance of StorkObservation. In addition, the user can access and enrich the observation data through the <code>StorkEventHandler</code>.</p> <p>A custom observation collector class should look as follows:</p> <pre><code>package examples;\n\nimport io.smallrye.stork.Stork;\nimport io.smallrye.stork.api.observability.ObservationCollector;\nimport io.smallrye.stork.api.observability.StorkEventHandler;\nimport io.smallrye.stork.api.observability.StorkObservation;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class AcmeObservationCollector implements ObservationCollector {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(AcmeObservationCollector.class);\n\n    private static final StorkEventHandler ACME_HANDLER = event -&gt; {\n        //This is the terminal event. Put here your custom logic to extend the metrics collection.\n\n        //E.g. Expose metrics to Micrometer, additional logs....\n        LOGGER.info( \"Service discovery took \" + event.getServiceDiscoveryDuration() + \".\");\n        LOGGER.info( event.getDiscoveredInstancesCount() + \" have been discovered for \" + event.getServiceName() + \".\");\n        LOGGER.info( \"Service selection took \" + event.getServiceSelectionDuration() + \".\");\n\n        //        ...\n\n    };\n\n    public static StorkObservation ACME_STORK_EVENT;\n\n    @Override\n    public StorkObservation create(String serviceName, String serviceDiscoveryType,\n                                   String serviceSelectionType) {\n        ACME_STORK_EVENT = new StorkObservation(\n                serviceName, serviceDiscoveryType, serviceSelectionType,\n                ACME_HANDLER);\n        return ACME_STORK_EVENT;\n    }\n}\n</code></pre> <p>The next step is to initialize Stork with an <code>ObservableStorkInfrastructure</code>, taking an instance of your <code>ObservationCollector</code> as parameter.</p> <pre><code>package examples;\n\nimport io.smallrye.stork.Stork;\nimport io.smallrye.stork.integration.ObservableStorkInfrastructure;\n\npublic class ObservableInitializationExample {\n\n    public static void main(String[] args) {\n        Stork.initialize(new ObservableStorkInfrastructure(new AcmeObservationCollector()));\n        Stork stork = Stork.getInstance();\n        // ...\n    }\n}\n</code></pre> <p>Then, Stork uses your implementation to register metrics.</p>"},{"location":"observability/#observing-service-discovery-and-selection-behaviours","title":"Observing service discovery and selection behaviours","text":"<p>To access metrics registered by <code>StorkObservation</code>, use the following code:</p> <pre><code>package examples;\n\nimport io.smallrye.mutiny.Uni;\nimport io.smallrye.stork.Stork;\nimport io.smallrye.stork.api.Service;\nimport io.smallrye.stork.api.ServiceInstance;\nimport io.smallrye.stork.api.observability.ObservationCollector;\nimport io.smallrye.stork.api.observability.StorkObservation;\n\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.Map;\n\nimport static examples.AcmeObservationCollector.*;\n\npublic class ObservationExample {\n\n    public static void example(Stork stork) {\n        Service service = stork.getService(\"my-service\");\n\n        ObservationCollector observations = service.getObservations();\n\n        // Gets the time spent in service discovery and service selection even if any error happens\n        Duration overallDuration = ACME_STORK_EVENT.getOverallDuration();\n\n        // Gets the total number of instances discovered\n        int discoveredInstancesCount = ACME_STORK_EVENT.getDiscoveredInstancesCount();\n\n        // Gets the error raised during the process\n        Throwable failure = ACME_STORK_EVENT.failure();\n\n        //        ...\n\n    }\n}\n</code></pre>"},{"location":"observability/#stork-observability-with-quarkus","title":"Stork Observability with Quarkus","text":"<p>Stork metrics are automatically enabled when using Stork together with the Micrometer extension in a Quarkus application. </p> <p>Micrometer collects the metrics of the rest and grpc client using Stork, as well as when using the Stork API.</p> <p>As an example, if you export the metrics to Prometheus, you will get:</p> <pre><code># HELP stork_load_balancer_failures_total The number of failures during service selection.\n# TYPE stork_load_balancer_failures_total counter\nstork_load_balancer_failures_total{service_name=\"hello-service\",} 0.0\n# HELP stork_service_selection_duration_seconds The duration of the selection operation \n# TYPE stork_service_selection_duration_seconds summary\nstork_service_selection_duration_seconds_count{service_name=\"hello-service\",} 13.0\nstork_service_selection_duration_seconds_sum{service_name=\"hello-service\",} 0.001049291\n# HELP stork_service_selection_duration_seconds_max The duration of the selection operation \n# TYPE stork_service_selection_duration_seconds_max gauge\nstork_service_selection_duration_seconds_max{service_name=\"hello-service\",} 0.0\n# HELP stork_overall_duration_seconds_max The total duration of the Stork service discovery and selection operations\n# TYPE stork_overall_duration_seconds_max gauge\nstork_overall_duration_seconds_max{service_name=\"hello-service\",} 0.0\n# HELP stork_overall_duration_seconds The total duration of the Stork service discovery and selection operations\n# TYPE stork_overall_duration_seconds summary\nstork_overall_duration_seconds_count{service_name=\"hello-service\",} 13.0\nstork_overall_duration_seconds_sum{service_name=\"hello-service\",} 0.001049291\n# HELP stork_service_discovery_failures_total The number of failures during service discovery\n# TYPE stork_service_discovery_failures_total counter\nstork_service_discovery_failures_total{service_name=\"hello-service\",} 0.0\n# HELP stork_service_discovery_duration_seconds_max The duration of the discovery operation\n# TYPE stork_service_discovery_duration_seconds_max gauge\nstork_service_discovery_duration_seconds_max{service_name=\"hello-service\",} 0.0\n# HELP stork_service_discovery_duration_seconds The duration of the discovery operation\n# TYPE stork_service_discovery_duration_seconds summary\nstork_service_discovery_duration_seconds_count{service_name=\"hello-service\",} 13.0\nstork_service_discovery_duration_seconds_sum{service_name=\"hello-service\",} 6.585046209\n# HELP stork_instances_count_total The number of service instances discovered\n# TYPE stork_instances_count_total counter\nstork_instances_count_total{service_name=\"hello-service\",} 26.0\n</code></pre>"},{"location":"programmatic-api/","title":"Stork Programmatic API","text":"<p>Stork proposes a programmatic API that lets you register new service Definitions and do manual lookup and selection. When using the programmatic API of Stork, you can: Retrieve the singleton Stork instance. This instance is configured with the set of Services it manages. Register new service definition. Retrieve the Service you want to use. Each Service is associated with a name. Retrieve the ServiceInstance, which will provide the metadata to access the actual instance.</p>"},{"location":"programmatic-api/#initializing-stork","title":"Initializing Stork","text":"<p>If your framework does not already provide a configured <code>Stork</code> instance, you need to do:</p> <pre><code>package examples;\n\nimport io.smallrye.stork.Stork;\nimport io.smallrye.stork.api.ServiceDefinition;\nimport io.smallrye.stork.api.ServiceInstance;\nimport io.smallrye.stork.loadbalancer.random.RandomConfiguration;\nimport io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration;\n\nimport java.time.Duration;\n\npublic class InitializationExample {\n\n    public static void main(String[] args) {\n        Stork.initialize();\n        Stork stork = Stork.getInstance();\n        // ...\n    }\n}\n</code></pre>"},{"location":"programmatic-api/#adding-service-dynamically","title":"Adding service dynamically","text":"<p>To register a new <code>ServiceDefinition</code>, use the <code>defineIfAbsent</code> method:</p> <pre><code>package examples;\n\nimport io.smallrye.stork.Stork;\nimport io.smallrye.stork.api.ServiceDefinition;\nimport io.smallrye.stork.loadbalancer.random.RandomConfiguration;\nimport io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration;\nimport io.smallrye.stork.serviceregistration.staticlist.StaticRegistrarConfiguration;\n\npublic class DefinitionExample {\n\n    public static void example(Stork stork) {\n        String example = \"localhost:8080, localhost:8081\";\n\n        // A service using a static list of locations as discovery\n        // As not set, it defaults to round-robin to select the instance.\n        stork.defineIfAbsent(\"my-service\",\n                ServiceDefinition.of(new StaticConfiguration().withAddressList(example)));\n\n        // Another service using the random selection strategy, instead of round-robin\n        stork.defineIfAbsent(\"my-second-service\",\n                ServiceDefinition.of(new StaticConfiguration().withAddressList(example),\n                        new RandomConfiguration()));\n\n        // Another service using the random selection strategy, instead of round-robin\n        // and a static service registrar\n        stork.defineIfAbsent(\"my-second-service\",\n                ServiceDefinition.of(new StaticConfiguration().withAddressList(example),\n                        new RandomConfiguration(), new StaticRegistrarConfiguration()));\n    }\n}\n</code></pre> <p>The <code>ServiceDefinition</code> instances can be created from:</p> <ul> <li>A service discovery configuration - these classes are provided by the service discovery implementations,</li> <li>An optional load balancer configuration - these classes are provided by the load balancer implementations</li> </ul> <p>Attributes from the service discovery and load balancer can be configured from the <code>Configuration</code> classes.</p>"},{"location":"programmatic-api/#looking-for-service-instances","title":"Looking for service instances","text":"<p>To list the service instances for a given service, or to select an instance according to the load balancer strategy, use the following code:</p> <pre><code>package examples;\n\nimport io.smallrye.mutiny.Uni;\nimport io.smallrye.stork.Stork;\nimport io.smallrye.stork.api.Service;\nimport io.smallrye.stork.api.ServiceDefinition;\nimport io.smallrye.stork.api.ServiceInstance;\nimport io.smallrye.stork.loadbalancer.random.RandomConfiguration;\nimport io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic class LookupExample {\n\n    public static void example(Stork stork) {\n        Service service = stork.getService(\"my-service\");\n\n        // Gets all the available instances:\n        Uni&lt;List&lt;ServiceInstance&gt;&gt; instances = service.getInstances();\n        // Select one instance using the load balancing strategy\n        Uni&lt;ServiceInstance&gt; instance = service.selectInstance();\n\n        // Gets all the managed services:\n        Map&lt;String, Service&gt; services = stork.getServices();\n    }\n}\n</code></pre> <p>The lookup and selection methods are returning Uni as these processes are asynchronous.</p>"},{"location":"programmatic-api/#all-in-one-example","title":"All in one example","text":"<p>The following snippet provides an all in one example of the Stork programmatic API:</p> <pre><code>package examples;\n\nimport io.smallrye.stork.Stork;\nimport io.smallrye.stork.api.ServiceDefinition;\nimport io.smallrye.stork.api.ServiceInstance;\nimport io.smallrye.stork.loadbalancer.random.RandomConfiguration;\nimport io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration;\nimport io.smallrye.stork.serviceregistration.staticlist.StaticRegistrarConfiguration;\n\nimport java.time.Duration;\n\npublic class StorkApiExample {\n\n    public static void main(String[] args) {\n        Stork.initialize();\n        Stork stork = Stork.getInstance();\n\n        String example = \"localhost:8080, localhost:8082\";\n\n        // A service using a static list of locations as discovery\n        // As not set, it defaults to round-robin to select the instance.\n        stork.defineIfAbsent(\"my-service\",\n                ServiceDefinition.of(new StaticConfiguration().withAddressList(example)));\n\n        // Another service using the random selection strategy, instead of round-robin\n        stork.defineIfAbsent(\"my-second-service\",\n                ServiceDefinition.of(new StaticConfiguration().withAddressList(example),\n                        new RandomConfiguration()));\n\n        ServiceInstance instance = stork.getService(\"my-second-service\").selectInstance()\n                .await().atMost(Duration.ofSeconds(1));\n        System.out.println(instance.getHost() + \":\" + instance.getPort());\n\n        // Another service using the random selection strategy, instead of round-robin\n        // and a static service registrar\n        stork.defineIfAbsent(\"my-third-service\",\n                ServiceDefinition.of(new StaticConfiguration().withAddressList(example),\n                        new RandomConfiguration(), new StaticRegistrarConfiguration()));\n    }\n}\n</code></pre>"},{"location":"quarkus/","title":"Using Stork with Quarkus","text":"<p>Quarkus is a Kubernetes Native Java stack tailored for OpenJDK HotSpot and GraalVM.</p> <p>Quarkus REST Client Reactive and gRPC extensions come with built-in integration with SmallRye Stork.</p> <p>This page describes how to use REST Client Reactive with Stork. Using gRPC with Stork is similar.</p> <p>We will use the Consul service discovery and the round-robin load balancer as examples.</p>"},{"location":"quarkus/#the-project","title":"The project","text":"<p>You can create a Quarkus project with the REST Client Reactive extension using code.quarkus.io.</p> <p>The corresponding Quarkus guide describes the extension in more detail.</p>"},{"location":"quarkus/#the-client","title":"The client","text":"<p>To use the REST client to communicate with a remote endpoint, you need to create an interface that describes how the communication should work. The client requires <code>baseUri</code> (or <code>baseUrl</code>) pointing to the address of the remote endpoint.</p> <p>To use Stork to determine the actual address, set the scheme of the URI to <code>stork</code> and the hostname of the URI to the name of the Stork service.</p> <p>For example, the <code>HelloClient</code> below will use the Stork service called <code>hello-service</code> to determine the address of the destination, and <code>/hello</code> as the base path for queries: <pre><code>package examples;\n\nimport jakarta.ws.rs.Consumes;\nimport jakarta.ws.rs.POST;\nimport jakarta.ws.rs.Path;\nimport jakarta.ws.rs.Produces;\nimport jakarta.ws.rs.core.MediaType;\nimport org.eclipse.microprofile.rest.client.inject.RegisterRestClient;\n\n\n\n@Path(\"/\")\n@RegisterRestClient(baseUri = \"stork://hello-service/hello\")\npublic interface HelloClient {\n    @POST\n    @Produces(MediaType.TEXT_PLAIN)\n    @Consumes(MediaType.TEXT_PLAIN)\n    String echo(String name);\n}\n</code></pre></p>"},{"location":"quarkus/#the-service","title":"The service","text":"<p>In Stork, a <code>Service</code> consists of service discovery and a load balancer.  The Service discovery is responsible for determining the <code>ServiceInstance</code>s, that is, available addresses for a service.  The load balancer picks a single <code>ServiceInstance</code> for a call.</p>"},{"location":"quarkus/#dependencies","title":"Dependencies","text":"<p>To use the service discovery and the load balancer of your choosing, you need to add the appropriate dependencies to your application.  For example, if you wish to use Consul and load-balance the calls with round-robin, add the following to your <code>pom.xml</code>:</p> <pre><code>    &lt;dependency&gt;\n        &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n        &lt;artifactId&gt;stork-service-discovery-consul&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n</code></pre> <p>Note</p> <p>No need to add a dependency for the round-robin load-balancer. This strategy is built-in. Also, no need to specify the stork version, Quarkus imports the Stork BOM.</p> <p>When using Eureka, Kubernetes, or any other service discovery mechanism, or a different load balancer, replace the dependencies above with the ones you need. Based on the defined dependencies, Stork automatically registers providers for service discovery mechanisms and load balancers.</p>"},{"location":"quarkus/#the-config","title":"The config","text":"<p>The last piece of the puzzle is the actual service configuration.  If your Consul instance is running on <code>localhost</code> on port <code>8500</code>, service discovery configuration should look as follows:</p> <pre><code>quarkus.stork.hello-service.service-discovery.type=consul\nquarkus.stork.hello-service.service-discovery.consul-host=localhost\nquarkus.stork.hello-service.service-discovery.consul-port=8500\n</code></pre> <p>Note</p> <p>When no load-balancing is configured, Stork uses a round-robin.</p>"},{"location":"springboot-config/","title":"Stork Spring Boot Config","text":"<p>Stork seamlessly supports Spring Boot configuration, facilitating access to configuration properties. This documentation elaborates on how Spring Boot developers can use Stork in their Spring Boot applications and configure it using the application.properties file.</p>"},{"location":"springboot-config/#dependency-setup","title":"Dependency setup","text":"<p>To enable Spring Boot configuration integration in Stork, you need to include the following dependency:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-spring-boot-config&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"springboot-config/#initializing-stork","title":"Initializing Stork","text":"<p>Since Spring Boot lacks a pre-configured Stork instance, you\u2019ll need create one. It can be done by providing a Spring bean performing Stork initialization:</p> <p><pre><code>package examples;\n\nimport io.smallrye.stork.Stork;\nimport io.smallrye.stork.springboot.SpringBootApplicationContextProvider;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.DependsOn;\n\n@SpringBootApplication\npublic class SpringBootInitializationExample {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootInitializationExample.class, args);\n    }\n\n    @Bean\n    @DependsOn(\"springBootApplicationContextProvider\")\n    public Stork stork() {\n        Stork.initialize();\n        Stork stork = Stork.getInstance();\n        return stork;\n    }\n\n    @Bean\n    public SpringBootApplicationContextProvider springBootApplicationContextProvider() {\n        return new SpringBootApplicationContextProvider();\n    }\n}\n</code></pre> Upon initialization, Stork scans for the <code>io.smallrye.stork.springboot.SpringBootConfigProvider</code> SPI provider and CDI beans (from version 2.x onwards).  It then builds a comprehensive list of managed services by parsing the properties configuration files.</p> <p>Please note the importance of the <code>io.smallrye.stork.springboot.SpringBootApplicationContextProvider</code> bean in our setup.  This bean has a critical role by granting Stork access to the current <code>org.springframework.context.ApplicationContext</code>. It enables it to retrieve configuration details effectively. Consequently, it\u2019s imperative that this bean is instantiated prior to initiating the Stork initialization process. In this case, we utilize the <code>@DependsOn</code> annotation for that. It allows us controlling the bean creation order.</p>"},{"location":"springboot-config/#comprehensive-example","title":"Comprehensive Example","text":"<p>You can check our Guitar Hero Application showcasing the seamless integration of Stork with Spring Boot Configuration. </p>"},{"location":"load-balancer/custom-load-balancer/","title":"Implement your own load balancer mechanism","text":"<p>Stork is extensible, and you can implement your service selection (load-balancer) mechanism.</p>"},{"location":"load-balancer/custom-load-balancer/#dependencies","title":"Dependencies","text":"<p>To implement your Load Balancer Provider, make sure your project depends on Core and Configuration Generator.  The former brings classes necessary to implement custom load balancer, the latter contains an annotation processor that generates classes needed by Stork.</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-core&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-configuration-generator&lt;/artifactId&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n    &lt;!-- provided scope is sufficient for the annotation processor --&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"load-balancer/custom-load-balancer/#implementing-a-load-balancer-provider","title":"Implementing a load balancer provider","text":"<p>Load balancer implementation consists of three elements:</p> <ul> <li><code>LoadBalancer</code> which is responsible for selecting service instances for a single Stork service,</li> <li><code>LoadBalancerProvider</code> which creates instances of <code>LoadBalancer</code> for a given load balancer type,</li> <li><code>$typeConfiguration</code> which is a configuration for the load balancer. This class is automatically generated.</li> </ul> <p>A type, for example <code>acme-load-balancer</code>, identifies each provider. This type is used in the configuration to reference the provider:</p> stork standalonestork in quarkus <pre><code>stork.my-service.load-balancer.type=acme-load-balancer\n</code></pre> <pre><code>quarkus.stork.my-service.load-balancer.type=acme-load-balancer \n</code></pre> <p>A <code>LoadBalancerProvider</code> implementation needs to be annotated with <code>@LoadBalancerType</code> that defines the type. Any configuration properties that the provider expects should be defined with <code>@LoadBalancerAttribute</code> annotations placed on the provider. Optionally, you can also add <code>@ApplicationScoped</code> annotation in order to provide the load balancer implementation as CDI bean.</p> <p>A load balancer provider class should look as follows: <pre><code>package examples;\n\nimport io.smallrye.stork.api.LoadBalancer;\nimport io.smallrye.stork.api.ServiceDiscovery;\nimport io.smallrye.stork.api.config.LoadBalancerAttribute;\nimport io.smallrye.stork.api.config.LoadBalancerType;\nimport io.smallrye.stork.spi.LoadBalancerProvider;\nimport jakarta.enterprise.context.ApplicationScoped;\n\n@LoadBalancerType(\"acme-load-balancer\")\n@LoadBalancerAttribute(name = \"my-attribute\",\n        description = \"Attribute that alters the behavior of the LoadBalancer\")\n@ApplicationScoped\npublic class AcmeLoadBalancerProvider implements\n        LoadBalancerProvider&lt;AcmeLoadBalancerConfiguration&gt; {\n\n    @Override\n    public LoadBalancer createLoadBalancer(AcmeLoadBalancerConfiguration config,\n                                           ServiceDiscovery serviceDiscovery) {\n        return new AcmeLoadBalancer(config);\n    }\n}\n</code></pre></p> <p>Note, that the <code>LoadBalancerProvider</code> interface takes a configuration class as a parameter.  This configuration class  is generated automatically by the Configuration Generator. Its name is created by appending <code>Configuration</code> to the load balancer type, like <code>AcmeLoadBalancerConfiguration</code>.</p> <p>The next step is to implement the <code>LoadBalancer</code> interface.</p> <p>The essence of load balancers\u2019 work happens in the <code>selectServiceInstance</code> method. The method returns a single <code>ServiceInstance</code> from a collection. </p> <pre><code>package examples;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Random;\n\nimport io.smallrye.stork.api.LoadBalancer;\nimport io.smallrye.stork.api.NoServiceInstanceFoundException;\nimport io.smallrye.stork.api.ServiceInstance;\n\npublic class AcmeLoadBalancer implements LoadBalancer {\n\n    private final Random random;\n\n    public AcmeLoadBalancer(AcmeLoadBalancerConfiguration config) {\n        random = new Random();\n    }\n\n    @Override\n    public ServiceInstance selectServiceInstance(Collection&lt;ServiceInstance&gt; serviceInstances) {\n        if (serviceInstances.isEmpty()) {\n            throw new NoServiceInstanceFoundException(\"No services found.\");\n        }\n        int index = random.nextInt(serviceInstances.size());\n        return new ArrayList&lt;&gt;(serviceInstances).get(index);\n    }\n\n    @Override\n    public boolean requiresStrictRecording() {\n        return false;\n    }\n}\n</code></pre> <p>This implementation is simplistic and just picks a random instance from the received list.</p> <p>Some load balancers make the pick based on statistics such as calls in progress or response times, or amount of errors of a service instance.  To collect this information in your load balancer, you can wrap the selected service instance into <code>ServiceInstanceWithStatGathering</code>.</p> <p>Load balancers based on statistics often expect that an operation using a selected service instance is marked as started before the next selection.  By default, Stork assumes that a <code>LoadBalancer</code> requires this and guards the calls accordingly.  If this is not the case for your implementation, override the <code>requiresStrictRecording()</code> method to return <code>false</code>.</p>"},{"location":"load-balancer/custom-load-balancer/#using-your-load-balancer","title":"Using your load balancer","text":"<p>In the project using it, don\u2019t forget to add the dependency on the module providing your implementation. Then, in the configuration, just add:</p> stork standalonestork in quarkus <pre><code>stork.my-service.service-discovery.type=...\nstork.my-service.load-balancer.type=acme-load-balancer\\\n</code></pre> <pre><code>quarkus.stork.my-service.service-discovery.type=...\nquarkus.stork.my-service.load-balancer.type=acme-load-balancer\n</code></pre> <p>Then, Stork will use your implementation to select the <code>my-service</code> service instance.</p>"},{"location":"load-balancer/custom-load-balancer/#using-your-load-balancer-using-the-programmatic-api","title":"Using your load balancer using the programmatic API","text":"<p>When building your load balancer project, the configuration generator creates a configuration class. This class can be used to configure your load balancer using the Stork programmatic API. </p> <pre><code>package examples;\n\nimport io.smallrye.mutiny.Uni;\nimport io.smallrye.stork.api.ServiceDefinition;\nimport io.smallrye.stork.api.ServiceInstance;\nimport io.smallrye.stork.api.StorkServiceRegistry;\nimport io.smallrye.stork.servicediscovery.staticlist.StaticConfiguration;\nimport io.smallrye.stork.serviceregistration.staticlist.StaticRegistrarConfiguration;\n\npublic class AcmeSelectorApiUsage {\n\n    public void example(StorkServiceRegistry stork) {\n        String list = \"localhost:8080, localhost:8081\";\n        stork.defineIfAbsent(\"my-service\", ServiceDefinition.of(\n                new StaticConfiguration().withAddressList(list),\n                new AcmeLoadBalancerConfiguration().withMyAttribute(\"my-value\"),new StaticRegistrarConfiguration())\n        );\n\n        Uni&lt;ServiceInstance&gt; uni = stork.getService(\"my-service\").selectInstance();\n    }\n\n}\n</code></pre> <p>Remember that attributes, like <code>my-attribute</code>, are declared using the <code>@LoadBalancerAttribute</code> annotation on the <code>LoadBalancerProvider</code> implementation.</p>"},{"location":"load-balancer/least-requests/","title":"Least Requests Load Balancing","text":"<p>The <code>least-requests</code> load balancing strategy monitors the number of inflight calls and selects the less-used instance.</p> <p>This strategy keeps track of the inflight calls made by the application and picks the service instance with the smallest number of inflight requests:</p> <ol> <li>when the selection happens, the service instance with the smallest number of inflight requests is selected, and this number is incremented</li> <li>when the operation completes, successfully or not, the number of inflight requests is decremented</li> </ol>"},{"location":"load-balancer/least-requests/#dependency","title":"Dependency","text":"<p>First, you need to add the <code>least-requests</code> load-balancer to your project:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-load-balancer-least-requests&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"load-balancer/least-requests/#configuration","title":"Configuration","text":"<p>For each service expected to use a least-response-time selection, configure the <code>load-balancer</code> to be <code>least-requests</code>:</p> stork standalonestork in quarkus <pre><code>stork.my-service.load-balancer.type=least-requests\n</code></pre> <pre><code>quarkus.stork.my-service.load-balancer.type=least-requests\n</code></pre> <p>Supported configuration properties are the following:</p> Attribute Mandatory Default Value Description"},{"location":"load-balancer/least-response-time/","title":"Least Response Time Load Balancing","text":"<p>The <code>least-response-time</code> load balancing strategy collects response times of the calls made with service instances and picks an instance based on this information.</p> <p>Erroneous responses are treated as responses with a long response time, by default 60 seconds. This can be controlled with the <code>error-penalty</code> attribute.</p> <p>The algorithm for service instance selection is as follows:</p> <ul> <li>if there is a service instance that wasn\u2019t used before - use it, otherwise:</li> <li>if there are any service instances with collected response times - select the one for which score is the lowest, otherwise:</li> <li>select a random instance</li> </ul> <p>The score for an instance decreases in time if an instance is not used. This way we ensure that instances that haven\u2019t been used in a long time, are retried.</p> <p>For the details on the score calculation, see Score calculation</p>"},{"location":"load-balancer/least-response-time/#dependency","title":"Dependency","text":"<p>To use this load balancer, start with adding the least-response-time load-balancer dependency to your project:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-load-balancer-least-response-time&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"load-balancer/least-response-time/#configuration","title":"Configuration","text":"<p>For each service expected to use a least-response-time selection, configure the <code>load-balancer</code> to be <code>least-response-time</code>:</p> stork standalonestork in quarkus <pre><code>stork.my-service.load-balancer.type=least-response-time\n</code></pre> <pre><code>quarkus.stork.my-service.load-balancer.type=least-response-time\n</code></pre> <p>The following attributes are supported:</p>"},{"location":"load-balancer/least-response-time/#score-calculation","title":"Score calculation","text":"<p>The score of a service instance is calculated by dividing a weighted sum of response times by sum of the weighs. The result is additionally adjusted to account for instances that haven\u2019t been used for a long time.</p> <p>Let:</p> <ul> <li>\\(n\\) denote how many instance selections were made so far</li> <li>\\(t_i\\) denote the response time for call \\(i\\)</li> <li>\\(n_i\\) denote the number of instance selections done until the moment of recording the response time for call \\(i\\)</li> <li>\\(n_{max}\\) denote the number of instance selections at the moment of last call recorded with this instance</li> <li>\\(\\delta\\) denote a configurable <code>declining-factor</code></li> </ul> <p>The idea for the weight is to decrease the importance of the data collected long time (many calls) ago. For call \\(i\\), the weight is calculated as follows: $$ w_i = \\delta ^ {(n - n_i)} $$</p> <p>The score of a service instance is calculated as: $$ score(n) = \\delta^{n - n_{max}} * \\frac{\\sum_i t_i * w_i}{\\sum_i w_i} = \\delta^{n - n_{max}} * \\frac{\\sum_i t_i * \\delta^{n - n_i}}{\\sum_i \\delta^{n - n_i}} $$</p> <p>The <code>declining-factor</code> should be in \\((0, 1]\\) , the default is \\(0.9\\). Using a lower value makes the older response times less important.</p> <p>Supported configuration properties are the following:</p> Attribute Mandatory Default Value Description <code>declining-factor</code> No <code>0.9</code> How much score should decline in time, see Score calculation in the docs for details. <code>error-penalty</code> No <code>60s</code> This load balancer treats an erroneous response as a response after this time. <code>use-secure-random</code> No <code>false</code> Whether the load balancer should use a SecureRandom instead of a Random (default). Check this page to understand the difference"},{"location":"load-balancer/overview/","title":"Overview","text":""},{"location":"load-balancer/overview/#load-balancer-service-selection-in-smallrye-stork","title":"Load Balancer / Service Selection in SmallRye Stork","text":"<p>Once services are registered and discovered, the next critical step is selecting which service instance will handle a given request.  SmallRye Stork provides flexible load balancing strategies to efficiently distribute requests across multiple instances of a service.  This ensures optimal resource usage, improved performance, and high availability.</p>"},{"location":"load-balancer/overview/#key-features","title":"Key Features:","text":"<ul> <li>Multiple Load Balancing Strategies: SmallRye Stork supports several built-in strategies for selecting service instances.  Check them out in the following dedicated sections.</li> <li>Customizable Strategies: You can define custom service selection strategies based on your unique use case or performance requirements, ensuring that the load balancer can adapt to specific needs.</li> </ul>"},{"location":"load-balancer/overview/#how-it-works","title":"How it Works:","text":"<p>Once a service has been registered and discovered, the load balancer comes into play when a client makes a request to that service.  Stork applies the configured load balancing strategy to select an instance from the available pool of discovered services.</p> <p>This feature ensures that your services remain responsive, scalable, and resilient, providing a smooth experience for both users and developers.</p>"},{"location":"load-balancer/power-of-two-choices/","title":"Power Of Two Choices Load Balancing","text":"<p>The <code>power-of-two-choices</code> load balancing selects two random service instances and then chooses the one with the least inflight requests. It avoids the overhead of <code>least-requests</code> and the worst case for <code>random</code> where it selects a busy destination.</p> <p>This strategy acts as follows:</p> <ol> <li>when the selection happens, it picks two random instances from the list,</li> <li>it returns the least loaded instance (based on the number of inflight requests),</li> <li>when the operation completes, successfully or not, the number of inflight requests for the instance is decremented.</li> </ol> <p>Check The Power of Two Random Choices paper to learn more about this pattern and the benefits.</p>"},{"location":"load-balancer/power-of-two-choices/#dependency","title":"Dependency","text":"<p>First, you need to add the random load-balancer to your project:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-load-balancer-power-of-two-choices&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"load-balancer/power-of-two-choices/#configuration","title":"Configuration","text":"<p>For each service expected to use a random service selection, configure the <code>load-balancer</code> to be <code>power-of-two-choices</code>:</p> stork standalonestork in quarkus <pre><code>stork.my-service.load-balancer.type=power-of-two-choices\n</code></pre> <pre><code>quarkus.stork.my-service.load-balancer.type=power-of-two-choices\n</code></pre> <p>Supported configuration properties are the following:</p> Attribute Mandatory Default Value Description <code>use-secure-random</code> No <code>false</code> Whether the load balancer should use a SecureRandom instead of a Random (default). Check this page to understand the difference"},{"location":"load-balancer/random/","title":"Random Load Balancing","text":"<p>The <code>random</code> load balancing is a straightforward service instance selection solution that picks a random instance every time.</p>"},{"location":"load-balancer/random/#dependency","title":"Dependency","text":"<p>First, you need to add the random load-balancer to your project:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-load-balancer-random&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"load-balancer/random/#configuration","title":"Configuration","text":"<p>For each service expected to use a random service selection, configure the <code>load-balancer</code> to be <code>random</code>:</p> stork standalonestork in quarkus <pre><code>stork.my-service.load-balancer.type=random\n</code></pre> <pre><code>quarkus.stork.my-service.load-balancer.type=random\n</code></pre> <p>Supported attributes are the following:</p> Attribute Mandatory Default Value Description <code>use-secure-random</code> No <code>false</code> Whether the load balancer should use a SecureRandom instead of a Random (default). Check this page to understand the difference"},{"location":"load-balancer/round-robin/","title":"Round-Robin Load Balancing","text":"<p>The round-robin is a straightforward load-balancing solution that just iterates over the set of service instances. While being simple, this solution shares the load among the instances and may be sufficient in many cases.</p> <p>The round-robin strategy is the default load-balancing strategy. It is provided by Stork itself, and so does not require an additional dependency.</p>"},{"location":"load-balancer/round-robin/#configuration","title":"Configuration","text":"<p>There is no need to configure the load-balancing strategy to be <code>round-robin</code>. Stork automatically uses this strategy when none are configured.</p> <p>However, you can also configure it explicitly as follows:</p> stork standalonestork in quarkus <pre><code>stork.my-service.load-balancer.type=round-robin\n</code></pre> <pre><code>quarkus.stork.my-service.load-balancer.type=round-robin\n</code></pre>"},{"location":"load-balancer/sticky/","title":"Sticky Load Balancing","text":"<p>The sticky load balancer selects a single service instance and keeps using it until it fails. Then, it selects another one.</p> <p>It is possible to configure a backoff time to specify for how long a failing service instance should not be retried.</p> <p>Precisely, the load balancer works as follows:</p> <ul> <li>if no service instance has been selected so far, select the first instance from the collection;</li> <li>else if the previously selected service instance has not failed, and is still available, return it;</li> <li>else return the first available service instance that has no recorded failure, if one exists;</li> <li>else, find the available instance for which the time since the last failure is the longest, and<ul> <li>if the backoff time since the failure passed, return it;</li> <li>or, throw an <code>NoAcceptableServiceInstanceFoundException</code> as no acceptable instances are available.</li> </ul> </li> </ul>"},{"location":"load-balancer/sticky/#configuration","title":"Configuration","text":"<p>To use the <code>sticky</code> load service selection strategy, set the load balancer type to <code>sticky</code>:</p> stork standalonestork in quarkus <pre><code>stork.my-service.load-balancer.type=sticky\n</code></pre> <pre><code>quarkus.stork.my-service.load-balancer.type=sticky\n</code></pre> <p>The following attributes are supported:</p> Attribute Mandatory Default Value Description <code>failure-backoff-time</code> No <code>0</code> After how much time, a service instance that has failed can be reused."},{"location":"service-discovery/composite/","title":"Composite Service Discovery","text":"<p>Some organizations use hybrid infrastructure. In such an infrastructure, different service instances may be discoverable via different service discovery providers. E.g. when serviceA is being migrated from a VM to Kubernetes, its older versions can be discovered via Consul and newer via Kubernetes. </p> <p><code>composite</code> service discovery addresses this problem by letting you define a service that consists of multiple services.</p>"},{"location":"service-discovery/composite/#dependency","title":"Dependency","text":"<p>To use the <code>composite</code> service discovery, first add the appropriate Service Discovery provider dependency to your project:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-service-discovery-composite&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"service-discovery/composite/#configuration","title":"Configuration","text":"<p>For each service that should consist of multiple services, configure the service discovery <code>type</code>, and set the <code>services</code> property to a comma separated list of services:</p> stork standalonestork in quarkus <pre><code>stork.my-service.service-discovery.type=composite\nstork.my-service.service-discovery.services=serviceA,serviceB\n\nstork.serviceA.service-discovery.type=...\nstork.serviceB.service-discovery.type=...\n</code></pre> <pre><code>quarkus.stork.my-service.service-discovery.type=composite\nquarkus.stork.my-service.service-discovery.services=serviceA,serviceB\n\nquarkus.stork.serviceA.service-discovery.type=...\nquarkus.stork.serviceB.service-discovery.type=...\n</code></pre> <p>Remember to define the services that make up your composite service.</p> <p>Be aware that Stork doesn\u2019t work as a standalone service discovery cluster.  Instead, it processes composite configurations\u2014meaning it handles multiple configurations that may use different service discovery implementation.  For each specific configuration, Stork delegates the service discovery task to the appropriate service discovery provider.  If one of these providers doesn\u2019t respond or fails, it affects Stork\u2019s ability to resolve that specific configuration, but it doesn\u2019t mean Stork itself is faulty;  it relies on the performance of the service discovery systems it\u2019s configured to work with.</p> <p>These are all the parameters of the composite service discovery:</p> Attribute Mandatory Default Value Description <code>services</code> Yes A comma-separated list of services that this services consists of."},{"location":"service-discovery/consul/","title":"Consul Service Discovery","text":"<p>Consul is a distributed, highly available, and data center aware solution to connect and configure applications across dynamic, distributed infrastructure. It\u2019s often used as service discovery backend to register and locate the services composing your system. Consul makes it simple for services to register themselves and to discover other services via a DNS or HTTP interface.  External services can be registered as well.</p> <p>As specified in the Consul documentation, if the host address is not provided, Stork will automatically use the Consul node address for the instance.</p> <p>This page explains how Stork can use Consul to handle the service discovery and service registration.</p>"},{"location":"service-discovery/consul/#dependency","title":"Dependency","text":"<p>First, you need to add the Stork Consul Service Discovery provider:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-service-discovery-consul&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"service-discovery/consul/#service-discovery-configuration","title":"Service discovery configuration","text":"<p>For each service that should get the service instances from Consul, configure the service discovery <code>type</code>:</p> stork standalonestork in quarkus <pre><code>stork.my-service.service-discovery.type=consul\n</code></pre> <pre><code>quarkus.stork.my-service.service-discovery.type=consul\n</code></pre> <p>Consul service discovery is configured with the following parameters:</p> Attribute Mandatory Default Value Description <code>consul-host</code> No <code>localhost</code> The Consul host. <code>consul-port</code> No <code>8500</code> The Consul port. <code>use-health-checks</code> No <code>true</code> Whether to use health check. <code>application</code> No The application name; if not defined Stork service name will be used. <code>refresh-period</code> No <code>5M</code> Service discovery cache refresh period. <code>secure</code> No whether the connection with the service should be encrypted with TLS."},{"location":"service-discovery/custom-service-discovery/","title":"Implement your own service discovery mechanism","text":"<p>Stork is extensible, and you can implement your own service discovery mechanism.</p>"},{"location":"service-discovery/custom-service-discovery/#dependencies","title":"Dependencies","text":"<p>To implement your Service Discovery Provider, make sure your project depends on Core and Configuration Generator.  The former brings classes necessary to implement custom discovery, the latter contains an annotation processor that generates classes needed by Stork.</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-core&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-configuration-generator&lt;/artifactId&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n    &lt;!-- provided scope is sufficient for the annotation processor --&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"service-discovery/custom-service-discovery/#implementing-a-service-discovery-provider","title":"Implementing a service discovery provider","text":"<p>Service discovery implementation consists of three elements:</p> <ul> <li><code>ServiceDiscovery</code> which is responsible for locating service instances for a single Stork service.</li> <li><code>ServiceDiscoveryProvider</code> which creates instances of <code>ServiceDiscovery</code> for a given service discovery type.</li> <li><code>$typeConfiguration</code> which is a configuration for the discovery. This class is automatically generated during the compilation (using an annotation processor).</li> </ul> <p>A type, for example, <code>acme</code>, identifies each provider. This type is used in the configuration to reference the provider:</p> stork standalonestork in quarkus <pre><code>stork.my-service.service-discovery.type=acme\n</code></pre> <pre><code>quarkus.stork.my-service.service-discovery.type=acme\n</code></pre> <p>A <code>ServiceDiscoveryProvider</code> implementation needs to be annotated with <code>@ServiceDiscoveryType</code> that defines the type. Any configuration properties that the provider expects should be defined with <code>@ServiceDiscoveryAttribute</code> annotations placed on the provider. Optionally, you can also add <code>@ApplicationScoped</code> annotation in order to provide the service discovery implementation as CDI bean.</p> <p>A service discovery provider class should look as follows:</p> <pre><code>package examples;\n\nimport io.smallrye.stork.api.ServiceDiscovery;\nimport io.smallrye.stork.api.config.ServiceConfig;\nimport io.smallrye.stork.api.config.ServiceDiscoveryAttribute;\nimport io.smallrye.stork.api.config.ServiceDiscoveryType;\nimport io.smallrye.stork.spi.StorkInfrastructure;\nimport io.smallrye.stork.spi.ServiceDiscoveryProvider;\nimport jakarta.enterprise.context.ApplicationScoped;\n\n@ServiceDiscoveryType(\"acme\")\n@ServiceDiscoveryAttribute(name = \"host\",\n        description = \"Host name of the service discovery server.\", required = true)\n@ServiceDiscoveryAttribute(name = \"port\",\n        description = \"Hort of the service discovery server.\", required = false)\n@ApplicationScoped\npublic class AcmeServiceDiscoveryProvider\n        implements ServiceDiscoveryProvider&lt;AcmeConfiguration&gt; {\n\n    @Override\n    public ServiceDiscovery createServiceDiscovery(\n            AcmeConfiguration config,\n            String serviceName,\n            ServiceConfig serviceConfig,\n            StorkInfrastructure storkInfrastructure) {\n        return new AcmeServiceDiscovery(config);\n    }\n}\n</code></pre> <p>Note, that the <code>ServiceDiscoveryProvider</code> interface takes a configuration class as a parameter. This configuration class  is generated automatically by the Configuration Generator.  Its name is created by appending <code>Configuration</code> to the service discovery type, such as <code>AcmeConfiguration</code>.</p> <p>The next step is to implement the <code>ServiceDiscovery</code> interface:</p> <pre><code>package examples;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport io.smallrye.mutiny.Uni;\nimport io.smallrye.stork.api.ServiceDiscovery;\nimport io.smallrye.stork.api.ServiceInstance;\nimport io.smallrye.stork.impl.DefaultServiceInstance;\nimport io.smallrye.stork.utils.ServiceInstanceIds;\n\npublic class AcmeServiceDiscovery implements ServiceDiscovery {\n\n    private final String host;\n    private final int port;\n\n    public AcmeServiceDiscovery(AcmeConfiguration configuration) {\n        this.host = configuration.getHost();\n        this.port = Integer.parseInt(configuration.getPort());\n    }\n\n    @Override\n    public Uni&lt;List&lt;ServiceInstance&gt;&gt; getServiceInstances() {\n        // Proceed to the lookup...\n        // Here, we just return a DefaultServiceInstance with the configured host and port\n        // The last parameter specifies whether the communication with the instance should\n        // happen over a secure connection\n        DefaultServiceInstance instance =\n                new DefaultServiceInstance(ServiceInstanceIds.next(), host, port, false);\n        return Uni.createFrom().item(() -&gt; Collections.singletonList(instance));\n    }\n}\n</code></pre> <p>This implementation is simplistic. Typically, instead of creating a service instance with values from the configuration, you would connect to a service discovery backend, look for the service and build the list of service instance accordingly. That\u2019s why the method returns a <code>Uni</code>. Most of the time, the lookup is a remote operation.</p> <p>As you can see, the <code>AcmeConfiguration</code> class gives access to the configuration attribute.</p>"},{"location":"service-discovery/custom-service-discovery/#using-your-service-discovery","title":"Using your service discovery","text":"<p>In the project using it, don\u2019t forget to add the dependency on the module providing your implementation. Then, in the configuration, just add:</p> stork standalonestork in quarkus <pre><code>stork.my-service.service-discovery.type=acme\nstork.my-service.service-discovery.host=localhost\nstork.my-service.service-discovery.port=1234\n</code></pre> <pre><code>quarkus.stork.my-service.service-discovery.type=acme\nquarkus.stork.my-service.service-discovery.host=localhost\nquarkus.stork.my-service.service-discovery.port=1234\n</code></pre> <p>Then, Stork will use your implementation to locate the <code>my-service</code> service.</p>"},{"location":"service-discovery/custom-service-discovery/#using-your-service-discovery-using-the-programmatic-api","title":"Using your service discovery using the programmatic API","text":"<p>When building your service discovery project, the configuration generator creates a configuration class. This class can be used to configure your service discovery using the Stork programmatic API.</p> <pre><code>package examples;\n\nimport io.smallrye.mutiny.Uni;\nimport io.smallrye.stork.api.ServiceDefinition;\nimport io.smallrye.stork.api.ServiceInstance;\nimport io.smallrye.stork.api.StorkServiceRegistry;\n\npublic class AcmeDiscoveryApiUsage {\n\n    public void example(StorkServiceRegistry stork) {\n        stork.defineIfAbsent(\"my-service\", ServiceDefinition.of(\n                new AcmeConfiguration().withHost(\"my-host\"))\n        );\n\n        Uni&lt;ServiceInstance&gt; uni = stork.getService(\"my-service\").selectInstance();\n    }\n\n}\n</code></pre> <p>Remember that attributes, like <code>host</code>, are declared using the <code>@ServiceDiscoveryAttribute</code> annotation on the <code>ServiceDiscoveryProvider</code> implementation.</p>"},{"location":"service-discovery/custom-service-discovery/#caching-the-service-instances","title":"Caching the service instances","text":"<p>Your <code>ServiceDiscovery</code> implementation can extend <code>io.smallrye.stork.impl.CachingServiceDiscovery</code> to automatically cache the service instances. In this case, the retrieved set of <code>ServiceInstance</code> is cached and only updated after some time. This duration is an additional configuration attribute. For homogeneity, we recommend the following attribute:</p> <pre><code>@ServiceDiscoveryAttribute(name = \"refresh-period\", description = \"Service discovery cache refresh period.\", \n        defaultValue = CachingServiceDiscovery.DEFAULT_REFRESH_INTERVAL)\n</code></pre> <p>The following snippet extends the acme service discovery with the <code>refresh-period</code> attribute:</p> <pre><code>package examples;\n\nimport io.smallrye.stork.api.ServiceDiscovery;\nimport io.smallrye.stork.api.config.ServiceConfig;\nimport io.smallrye.stork.api.config.ServiceDiscoveryAttribute;\nimport io.smallrye.stork.api.config.ServiceDiscoveryType;\nimport io.smallrye.stork.impl.CachingServiceDiscovery;\nimport io.smallrye.stork.spi.ServiceDiscoveryProvider;\nimport io.smallrye.stork.spi.StorkInfrastructure;\nimport jakarta.enterprise.context.ApplicationScoped;\n\n@ServiceDiscoveryType(\"cached-acme\")\n@ServiceDiscoveryAttribute(name = \"host\",\n        description = \"Host name of the service discovery server.\", required = true)\n@ServiceDiscoveryAttribute(name = \"port\",\n        description = \"Hort of the service discovery server.\", required = false)\n@ServiceDiscoveryAttribute(name = \"refresh-period\",\n        description = \"Service discovery cache refresh period.\",\n        defaultValue = CachingServiceDiscovery.DEFAULT_REFRESH_INTERVAL)\n@ApplicationScoped\npublic class CachedAcmeServiceDiscoveryProvider\n        implements ServiceDiscoveryProvider&lt;CachedAcmeConfiguration&gt; {\n\n    @Override\n    public ServiceDiscovery createServiceDiscovery(\n            CachedAcmeConfiguration config,\n            String serviceName,\n            ServiceConfig serviceConfig,\n            StorkInfrastructure storkInfrastructure) {\n        return new CachedAcmeServiceDiscovery(config);\n    }\n}\n</code></pre> <p>Extending <code>io.smallrye.stork.impl.CachingServiceDiscovery</code> changes the structure of the service discovery implementation:</p> <pre><code>package examples;\n\nimport io.smallrye.mutiny.Uni;\nimport io.smallrye.stork.api.ServiceDiscovery;\nimport io.smallrye.stork.api.ServiceInstance;\nimport io.smallrye.stork.impl.CachingServiceDiscovery;\nimport io.smallrye.stork.impl.DefaultServiceInstance;\nimport io.smallrye.stork.utils.ServiceInstanceIds;\n\nimport java.util.Collections;\nimport java.util.List;\n\npublic class CachedAcmeServiceDiscovery extends CachingServiceDiscovery {\n\n    private final String host;\n    private final int port;\n\n    public CachedAcmeServiceDiscovery(CachedAcmeConfiguration configuration) {\n        super(configuration.getRefreshPeriod()); // (1)\n        this.host = configuration.getHost();\n        this.port = Integer.parseInt(configuration.getPort());\n    }\n\n    @Override  // (2)\n    public Uni&lt;List&lt;ServiceInstance&gt;&gt; fetchNewServiceInstances(List&lt;ServiceInstance&gt; previousInstances) {\n        // Retrieve services...\n        DefaultServiceInstance instance =\n                new DefaultServiceInstance(ServiceInstanceIds.next(), host, port, false);\n        return Uni.createFrom().item(() -&gt; Collections.singletonList(instance));\n    }\n}\n</code></pre> <ol> <li>Call the <code>super</code> constructor with the <code>refresh-period</code> value</li> <li>Implement <code>fetchNewServiceInstances</code> instead of <code>getServiceInstances</code>.    The method is called periodically, and the retrieved instances are cached.    This implementation is simplistic.</li> </ol> <p>If the retrieval fails, the error is reported, and Stork keeps the previously retrieved list of instances.</p>"},{"location":"service-discovery/custom-service-discovery/#customizing-the-caching-strategy","title":"Customizing the caching strategy","text":"<p>Sometimes it can be useful to change this behaviour and customize the cache expiration strategy.</p> <p>For example, imagine you are using a backend service discovery where service instances can change very frequently.</p> <p>Moreover, contacting the backend service discovery can be expensive in terms of computing, thus finding a good value for the refreshing time can be mission impossible.</p> <p>For these situations, Stork allows to implement a better expiration strategy for the cache. </p> <p>If you want to customize the expiration strategy, you need: 1. Implement the <code>cache</code> method where the expiration strategy should be defined. 2. Invalidate the cache when expiration condition evaluates to true.</p> <p>Look at the example bellow:</p> <pre><code>package examples;\n\nimport io.smallrye.mutiny.Uni;\nimport io.smallrye.stork.api.ServiceInstance;\nimport io.smallrye.stork.impl.CachingServiceDiscovery;\nimport io.smallrye.stork.impl.DefaultServiceInstance;\nimport io.smallrye.stork.utils.ServiceInstanceIds;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\npublic class CustomExpirationCachedAcmeServiceDiscovery extends CachingServiceDiscovery {\n\n    private final String host;\n    private final int port;\n\n    private AtomicBoolean invalidated = new AtomicBoolean();\n\n    public CustomExpirationCachedAcmeServiceDiscovery(CachedAcmeConfiguration configuration) {\n        super(configuration.getRefreshPeriod());\n        this.host = configuration.getHost();\n        this.port = Integer.parseInt(configuration.getPort());\n    }\n\n    @Override\n    public Uni&lt;List&lt;ServiceInstance&gt;&gt; fetchNewServiceInstances(List&lt;ServiceInstance&gt; previousInstances) {\n        // Retrieve services...\n        DefaultServiceInstance instance =\n                new DefaultServiceInstance(ServiceInstanceIds.next(), host, port, false);\n        return Uni.createFrom().item(() -&gt; Collections.singletonList(instance));\n    }\n\n    @Override\n    public Uni&lt;List&lt;ServiceInstance&gt;&gt; cache(Uni&lt;List&lt;ServiceInstance&gt;&gt; uni) {\n        return uni.memoize().until(() -&gt; invalidated.get());\n    }\n\n    //command-based cache invalidation: user triggers the action to invalidate the cache.\n    public void invalidate() {\n        invalidated.set(true);\n    }\n\n}\n</code></pre> <p>Additionally, you can check the Kubernetes Service Discovery for further details about an event-based invalidation example.</p>"},{"location":"service-discovery/dns/","title":"DNS Service Discovery","text":"<p>DNS is a name resolution protocol used to determine IP addresses for hostnames. That makes it a natural fit for service discovery. Consul and AWS Cloud Map provide DNS resolutions for service discovery.</p> <p>This page explains how Stork can use DNS to handle the service discovery.</p>"},{"location":"service-discovery/dns/#dns-records","title":"DNS records","text":"<p>DNS supports a variety of record types. Stork can resolve hostnames to addresses based on SRV, A and AAAA records. All these types of records may return multiple addresses for a single hostname. You may choose to not resolve target hostnames.</p> <p>While A and AAAA records are quite similar, they just carry an IP (v4 for A and v6 for AAAA), the SRV records are different. They contain a weight, a target and a port for a service instance. The target returned in an SRV record needs to be resolved further by an A or an AAAA record.</p> <p>In short, it works as follows:</p> <p> </p>"},{"location":"service-discovery/dns/#dependency","title":"Dependency","text":"<p>To use the DNS service discovery, you need to add the Stork DNS Service Discovery provider dependency to your project:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-service-discovery-dns&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"service-discovery/dns/#configuration","title":"Configuration","text":"<p>Next, set the service discovery <code>type</code> to <code>dns</code>. Additionally, you would usually specify the DNS server, or servers, to use for the discovery.  All in all, your configuration could look as follows:</p> stork standalonestork in quarkus <pre><code>stork.my-service.service-discovery.type=dns\n# optional dns servers:\nstork.my-service.service-discovery.dns-servers=my-dns-server:8221,my-dns-server2\n</code></pre> <pre><code>quarkus.stork.my-service.service-discovery.type=dns\n\n# optional dns servers:\nquarkus.stork.my-service.service-discovery.dns-servers=my-dns-server:8221,my-dns-server2\n</code></pre> <p>All the available parameters are as follows:</p> Attribute Mandatory Default Value Description <code>dns-servers</code> No <code>none</code> Comma separated list of dns servers. Servers can either be in the <code>server:port</code> or just <code>server</code> form. Use <code>none</code> to use the system resolver. <code>hostname</code> No The hostname to look up; if not defined Stork service name will be used. <code>record-type</code> No <code>SRV</code> Type of the DNS record. A, AAAA and SRV records are supported <code>port</code> No Port of the service instances. Required if the record type is other than SRV. <code>refresh-period</code> No <code>5M</code> Service discovery cache refresh period. <code>secure</code> No Whether the connection with the service should be encrypted with TLS. <code>recursion-desired</code> No <code>true</code> Whether DNS recursion is desired <code>resolve-srv</code> No <code>true</code> Whether DNS resolution for SRV records is desired <code>dns-timeout</code> No <code>5s</code> Timeout for DNS queries <code>fail-on-error</code> No <code>false</code> Whether an error in retrieving service instances from one of the DNS servers should cause a failure of the discovery attempt."},{"location":"service-discovery/eureka/","title":"Eureka Service Discovery","text":"<p>Eureka is a RESTful service that is primarily used in the AWS cloud for the purpose of discovery, load balancing, and failover of middle-tier servers.</p> <p>This page explains how Stork can use Eureka to handle the service discovery and service registration.</p>"},{"location":"service-discovery/eureka/#dependency","title":"Dependency","text":"<p>First, you need to add the Stork Eureka Service Discovery provider:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-service-discovery-eureka&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"service-discovery/eureka/#service-discovery-configuration","title":"Service discovery configuration","text":"<p>For each application instance expected to be registered in Eureka, configure the lookup:</p> stork standalonestork in quarkus <pre><code>stork.my-service.service-discovery.type=eureka\nstork.my-service.service-discovery.eureka-host=localhost\nstork.my-service.service-discovery.eureka-port=8761\n</code></pre> <pre><code>quarkus.stork.my-service.service-discovery.type=eureka\nquarkus.stork.my-service.service-discovery.eureka-host=localhost\nquarkus.stork.my-service.service-discovery.eureka-port=8761\n</code></pre> <p>Stork looks for the service with the given name (<code>my-service</code> in the previous example).</p> <p>Supported attributes are the following:</p> Attribute Mandatory Default Value Description <code>eureka-host</code> Yes The Eureka server host. <code>eureka-port</code> No <code>8761</code> The Eureka server port. <code>eureka-context-path</code> No <code>/</code> The Eureka server root context path. <code>application</code> No The Eureka application Id; if not defined Stork service name will be used <code>eureka-trust-all</code> No <code>false</code> Enable/Disable the TLS certificate verification <code>eureka-tls</code> No <code>false</code> Use TLS to connect to the Eureka server <code>instance</code> No The Eureka application instance Id <code>refresh-period</code> No <code>5M</code> Service discovery cache refresh period. <code>secure</code> No <code>false</code> Whether is should select the secured endpoint of the retrieved services. <p>The <code>application</code> attribute is optional. It uses the Stork service name (<code>my-service</code> in the previous configuration) if not set.</p> <p>The <code>instance</code> attribute allows selecting a specific instance. Using this attribute prevents load-balancing as you will always select a single instance.</p> <p>The <code>secure</code> attribute indicates if you want the secure virtual address of the application instance. If set to <code>true</code>, unsecured instances are filtered out from the available instances.</p>"},{"location":"service-discovery/knative/","title":"Knative Service Discovery","text":"<p>Knative is a Kubernetes-based platform for serverless workloads. Knative provides a set of objects as Kubernetes Custom Resource Definitions (CRDs).  These resources are used to define and control how your serverless workload behaves on the cluster.  The Stork Knative service discovery implementation is very similar to the Kubernetes one.  Stork will ask for Knative services to the cluster instead of vanilla Kubernetes services used by the Kubernetes implementation.  To do so, Stork uses Fabric 8 Knative Client which is just an extension of Fabric8 Kubernetes Client. </p>"},{"location":"service-discovery/knative/#dependency","title":"Dependency","text":"<p>First, you need to add the Stork Knative Service Discovery provider:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-service-discovery-knative&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"service-discovery/knative/#a-few-words-about-server-authentication","title":"A few words about server authentication.","text":"<p>Stork uses Fabric8 Knative Client which is a Fabric8 Kubernetes Client extension to access the Kubernetes resources, concretely the <code>DefaultKnativeClient</code> implementation.</p> <p>Since Knative Client is just an extension of Fabric8 Kubernetes Client, it\u2019s also possible to get an instance of KnativeClient from KubernetesClient.</p> <p><code>DefaultKubernetesClient</code> will try to read the <code>~/.kube/config</code> file from your local machine and load the token for authenticating with the Kubernetes API server.</p> <p>The level of access (Roles) depends on the configured <code>ServiceAccount</code>.</p> <p>You can override this configuration if you want fine-grain control.</p>"},{"location":"service-discovery/knative/#role-based-access-control-rbac","title":"Role-based access control (RBAC)","text":"<p>If you\u2019re using a Kubernetes cluster with Role-Based Access Control (RBAC) enabled, the default permissions for a ServiceAccount don\u2019t allow it to list or modify any resources. A <code>ServiceAccount</code>, a <code>Role</code> and a <code>RoleBinding</code> are needed in order to allow Stork to list the available service instances from the cluster or the namespace.</p> <p>An example that allows listing all endpoints could look something like this:</p> <pre><code>---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: &lt;appname&gt;\n  namespace: &lt;namespace&gt;\n---\nkind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: &lt;appname&gt;\n  namespace: &lt;namespace&gt;\nrules:\n  - apiGroups: [\"\"] # \"\" indicates the core API group\n    resources: [\"endpoints\", \"pods\"] # stork queries service endpoints and pods\n    verbs: [\"get\", \"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1beta1\nkind: RoleBinding\nmetadata:\n  name: &lt;appname&gt;\n  namespace: &lt;namespace&gt;\nsubjects:\n  - kind: ServiceAccount\n    # Reference to upper's `metadata.name`\n    name: &lt;appname&gt;\n    # Reference to upper's `metadata.namespace`\n    namespace: &lt;namespace&gt;\nroleRef:\n  kind: Role\n  name: &lt;appname&gt;\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"service-discovery/knative/#configuration","title":"Configuration","text":"<p>For each service expected to be exposed as Kubernetes Service, configure the lookup:</p> stork standalonestork in quarkus <pre><code>stork.my-knservice.service-discovery.type=knative\nstork.my-knservice.service-discovery.knative-namespace=my-namespace\n</code></pre> <pre><code>quarkus.stork.my-knservice.service-discovery.type=knative\nquarkus.stork.my-knservice.service-discovery.knative-namespace=my-namespace\n</code></pre> <p>Stork looks for the Knative Service with the given name (<code>my-knservice</code> in the previous example) in the specified namespace.</p> <p>Stork inspects the Knative Service and retrieves the url of the service.</p> <p>Supported attributes are the following:</p> Attribute Mandatory Default Value Description <code>knative-host</code> No The Knative API host. <code>knative-namespace</code> No The namespace of the service. Use all to discover all namespaces. <code>application</code> No The Knative application Id; if not defined Stork service name will be used. <code>refresh-period</code> No <code>5M</code> Service discovery cache refresh period. <code>secure</code> No Whether the connection with the service should be encrypted with TLS."},{"location":"service-discovery/knative/#caching-the-service-instances","title":"Caching the service instances","text":"<p>Contacting the cluster too much frequently can result in performance problems. It\u2019s why Knative Service discovery extends <code>io.smallrye.stork.impl.CachingServiceDiscovery</code> to automatically cache the service instances. Moreover, the caching expiration has been also improved in order to only update the retrieved set of <code>ServiceInstance</code> if some of them changes and an event is emitted.  This is done by creating an Informer, similar to a Watch,  able to observe the events on the Knative Service instances resources. </p> <p>Note that:   - the cache is invalidated when an event is received.   - the cache is validated once the instances are retrieved from the cluster, in the <code>fetchNewServiceInstances</code> method.  - the <code>cache</code> method is overrided to customize the expiration strategy. In this case the collection of service instances will be kept until an event occurs.</p>"},{"location":"service-discovery/kubernetes/","title":"Kubernetes Service Discovery","text":"<p>Kubernetes has a built-in support for service discovery and load-balancing. However, you may need more flexibility to carefully select the service instance you want.</p> <p>This page explains how Stork can use the Kubernetes API to handle the service discovery.</p>"},{"location":"service-discovery/kubernetes/#dependency","title":"Dependency","text":"<p>First, you need to add the Stork Kubernetes Service Discovery provider:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-service-discovery-kubernetes&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"service-discovery/kubernetes/#a-few-words-about-server-authentication","title":"A few words about server authentication.","text":"<p>Stork uses Fabric8 Kubernetes Client to access the Kubernetes resources, concretely the <code>DefaultKubernetesClient</code> implementation. </p> <p>It will try to read the <code>~/.kube/config</code> file from your local machine and load the token for authenticating with the Kubernetes API server.</p> <p>If you are using the Stork Kubernetes discovery provider from inside a Pod, it loads <code>~/.kube/config</code> from the container file system.</p> <p>This file is automatically mounted inside the Pod.</p> <p>The level of access (Roles) depends on the configured <code>ServiceAccount</code>.</p> <p>You can override this configuration if you want fine-grain control.</p>"},{"location":"service-discovery/kubernetes/#role-based-access-control-rbac","title":"Role-based access control (RBAC)","text":"<p>If you\u2019re using a Kubernetes cluster with Role-Based Access Control (RBAC) enabled, the default permissions for a ServiceAccount don\u2019t allow it to list or modify any resources.  A <code>ServiceAccount</code>, a <code>Role</code> and a <code>RoleBinding</code> are needed in order to allow Stork to list the available service instances from the cluster or the namespace. </p> <p>An example that allows listing all endpoints could look something like this:</p> <pre><code>------\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: &lt;appname&gt;\n  namespace: &lt;namespace&gt;\n---\nkind: Role\napiVersion: rbac.authorization.k8s.io/v1\nmetadata:\n  name: &lt;appname&gt;\n  namespace: &lt;namespace&gt;\nrules:\n  - apiGroups: [\"\"] # \"\" indicates the core API group\n    resources: [\"endpoints\", \"pods\"] # stork queries service endpoints and pods\n    verbs: [\"get\", \"list\"]\n---\napiVersion: rbac.authorization.k8s.io/v1beta1\nkind: RoleBinding\nmetadata:\n  name: &lt;appname&gt;\n  namespace: &lt;namespace&gt;\nsubjects:\n  - kind: ServiceAccount\n    # Reference to upper's `metadata.name`\n    name: &lt;appname&gt;\n    # Reference to upper's `metadata.namespace`\n    namespace: &lt;namespace&gt;\nroleRef:\n  kind: Role\n  name: &lt;appname&gt;\n  apiGroup: rbac.authorization.k8s.io\n</code></pre>"},{"location":"service-discovery/kubernetes/#configuration","title":"Configuration","text":"<p>For each service expected to be exposed as Kubernetes Service, configure the lookup:</p> stork standalonestork in quarkus <pre><code>stork.my-service.service-discovery.type=kubernetes\nstork.my-service.service-discovery.k8s-namespace=my-namespace\n</code></pre> <pre><code>quarkus.stork.my-service.service-discovery.type=kubernetes\nquarkus.stork.my-service.service-discovery.k8s-namespace=my-namespace\n</code></pre> <p>Stork looks for the Kubernetes Service with the given name (<code>my-service</code> in the previous example) in the specified namespace.</p> <p>Instead of using the Kubernetes Service IP directly, and let Kubernetes handle the selection and balancing, Stork inspects the service and retrieves the list of pods providing the service. Then, it can select the instance.</p> <p>Supported attributes are the following:</p> Attribute Mandatory Default Value Description <code>k8s-host</code> No The Kubernetes API host. <code>k8s-namespace</code> No The namespace of the service. Use all to discover all namespaces. <code>application</code> No The Kubernetes application Id; if not defined Stork service name will be used. <code>port-name</code> No The Kubernetes application port name. If not defined, when exposing multiple ports, Stork will use the first one. <code>refresh-period</code> No <code>5M</code> Service discovery cache refresh period. <code>secure</code> No Whether the connection with the service should be encrypted with TLS."},{"location":"service-discovery/kubernetes/#caching-the-service-instances","title":"Caching the service instances","text":"<p>Contacting the cluster too much frequently can result in performance problems. It\u2019s why Kubernetes Service discovery extends <code>io.smallrye.stork.impl.CachingServiceDiscovery</code> to automatically cache the service instances. Moreover, the caching expiration has been also improved in order to only update the retrieved set of <code>ServiceInstance</code> if some of them changes and an event is emitted.  This is done by creating an Informer, similar to a Watch,  able to observe the events on the service instances resources. </p> <p>Note that:   - the cache is invalidated when an event is received.   - the cache is validated once the instances are retrieved from the cluster, in the <code>fetchNewServiceInstances</code> method.  - the <code>cache</code> method is overrided to customize the expiration strategy. In this case the collection of service instances will be kept until an event occurs.</p>"},{"location":"service-discovery/overview/","title":"Overview","text":""},{"location":"service-discovery/overview/#service-discovery-in-smallrye-stork","title":"Service Discovery in SmallRye Stork","text":"<p>As already introduced, service discovery is a crucial part of modern microservices architectures.  It allows services to dynamically discover the location of other services at runtime, which is particularly useful in distributed systems where services may scale up or down, or change their network addresses.</p> <p>SmallRye Stork provides a flexible and extensible mechanism for service discovery. It supports out of the box some service discovery such as Kubernetes or Consul but the main strength of it is customization so you can easily create your own implementation related on your business for example. Stork allows services to communicate with each other without requiring hardcoded addresses, making it an ideal solution for microservices deployments. SmallRye Stork brings this capability to clients for Quarkus applications but it\u2019s vendor agnostic so you easily use it with other solutions and even in standalone mode.</p> <p>You can explore the different implementations and learn how to create your own in the following sections.</p>"},{"location":"service-discovery/static-list/","title":"Static List Service Discovery","text":"<p>In some situations, such as demos, development, or testing, you may want to mock the service discovery by providing a predefined list of service instances. For this purpose, Stork comes with a <code>static</code> service discovery type.</p>"},{"location":"service-discovery/static-list/#dependency","title":"Dependency","text":"<p>To use the <code>static</code> service discovery, first add the appropriate Service Discovery provider dependency to your project:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-service-discovery-static-list&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"service-discovery/static-list/#configuration","title":"Configuration","text":"<p>For each service that should use the static list of service instances configure the service registrar <code>type</code>:</p> stork standalonestork in quarkus <pre><code>stork.my-service.service-discovery.type=static\nstork.my-service.service-discovery.address-list=localhost:8080,localhost:8081\n</code></pre> <pre><code>quarkus.stork.my-service.service-discovery.type=static\nquarkus.stork.my-service.service-discovery.address-list=localhost:8080,localhost:8081\n</code></pre> <p>These are all the static service discovery parameters:</p> Attribute Mandatory Default Value Description <code>address-list</code> Yes A comma-separated list of addresses (host:port). The default port is 80. <code>secure</code> No Whether the connection with the service should be encrypted with TLS. Default is false, except if the host:port uses the port is 443. <code>shuffle</code> No <code>false</code> Whether the list of address must be shuffled to avoid using the first address on every startup."},{"location":"service-registration/consul/","title":"Consul Service Registration","text":"<p>Consul is a distributed, highly available, and data center aware solution to connect and configure applications across dynamic, distributed infrastructure. It\u2019s often used as service discovery backend to register and locate the services composing your system. Consul makes it simple for services to register themselves and to discover other services via a DNS or HTTP interface.  External services can be registered as well.</p> <p>This page explains how Stork can use Consul to handle the service registration.</p>"},{"location":"service-registration/consul/#dependency","title":"Dependency","text":"<p>First, you need to add the Stork Consul Service Registration provider:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-service-registration-consul&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"service-registration/consul/#service-registration-configuration","title":"Service registration configuration","text":"<p>For each service that should register the service instances in Consul, configure the service registrar <code>type</code>:</p> stork standalone <pre><code>stork.my-service.service-registrar.type=consul\n</code></pre> stork in quarkus <pre><code>quarkus.stork.my-service.service-registrar.type=consul\n</code></pre> <p>Consul service registrar is configured with the following parameters:</p> Attribute Mandatory Default Value Description <code>consul-host</code> No <code>localhost</code> The Consul host. <code>consul-port</code> No <code>8500</code> The Consul port."},{"location":"service-registration/custom-service-registration/","title":"Implement your own service registration mechanism","text":"<p>Stork is extensible, and you can implement your own service registrar mechanism.</p>"},{"location":"service-registration/custom-service-registration/#dependencies","title":"Dependencies","text":"<p>To implement your Service Registration Provider, make sure your project depends on Core and Configuration Generator.  The former brings classes necessary to implement custom registrar, the latter contains an annotation processor that generates classes needed by Stork.</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-core&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-configuration-generator&lt;/artifactId&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n    &lt;!-- provided scope is sufficient for the annotation processor --&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"service-registration/custom-service-registration/#implementing-a-service-registrar-provider","title":"Implementing a service registrar provider","text":"<p>Service discovery implementation consists of three elements:</p> <ul> <li><code>ServiceRegistrar</code> which is responsible for registering service instances for a single Stork service.</li> <li><code>ServiceRegistrarProvider</code> which creates instances of <code>ServiceRegistrar</code> for a given service registrar type.</li> <li><code>$typeConfiguration</code> which is a configuration for the registrar. This class is automatically generated during the compilation (using an annotation processor).</li> </ul> <p>A type, for example, <code>acme</code>, identifies each provider. This type is used in the configuration to reference the provider:</p> stork standalonestork in quarkus <pre><code>stork.my-service.service-registrar.type=acme\n</code></pre> <pre><code>quarkus.stork.my-service.service-registrar.type=acme\n</code></pre> <p>A <code>ServiceRegistrarProvider</code> implementation needs to be annotated with <code>@ServiceRegistrarType</code> that defines the type. Any configuration properties that the provider expects should be defined with <code>@ServiceRegistrarAttribute</code> annotations placed on the provider. Optionally, you can also add <code>@ApplicationScoped</code> annotation in order to provide the service registrar implementation as CDI bean.</p> <p>A service registrar provider class should look as follows:</p> <pre><code>package examples;\n\nimport io.smallrye.stork.api.Metadata;\nimport io.smallrye.stork.api.ServiceRegistrar;\nimport io.smallrye.stork.api.config.ServiceRegistrarAttribute;\nimport io.smallrye.stork.api.config.ServiceRegistrarType;\nimport io.smallrye.stork.spi.ServiceRegistrarProvider;\nimport io.smallrye.stork.spi.StorkInfrastructure;\nimport jakarta.enterprise.context.ApplicationScoped;\n\n@ServiceRegistrarType(value = \"acme\", metadataKey = Metadata.DefaultMetadataKey.class)\n@ServiceRegistrarAttribute(name = \"host\",\n        description = \"Host name of the service discovery server.\", required = true)\n@ServiceRegistrarAttribute(name = \"port\",\n        description = \"Hort of the service discovery server.\", required = false)\n@ApplicationScoped\npublic class AcmeServiceRegistrarProvider\n        implements ServiceRegistrarProvider&lt;AcmeRegistrarConfiguration, Metadata.DefaultMetadataKey&gt; {\n\n    @Override\n    public ServiceRegistrar createServiceRegistrar(\n            AcmeRegistrarConfiguration config,\n            String serviceName,\n            StorkInfrastructure storkInfrastructure) {\n        return new AcmeServiceRegistrar(config);\n    }\n\n}\n</code></pre> <p>Note, that the <code>ServiceRegistrarProvider</code> interface takes a configuration class as a parameter. This configuration class  is generated automatically by the Configuration Generator.  Its name is created by appending <code>Configuration</code> to the service discovery type, such as <code>AcmeConfiguration</code>.</p> <p>The next step is to implement the <code>ServiceRegistrar</code> interface:</p> <pre><code>package examples;\n\nimport io.smallrye.mutiny.Uni;\nimport io.smallrye.stork.api.Metadata;\nimport io.smallrye.stork.api.ServiceRegistrar;\n\npublic class AcmeServiceRegistrar implements ServiceRegistrar {\n\n    private final String backendHost;\n    private final int backendPort;\n\n    public AcmeServiceRegistrar(AcmeRegistrarConfiguration configuration) {\n        this.backendHost = configuration.getHost();\n        this.backendPort = Integer.parseInt(configuration.getPort());\n    }\n\n\n    @Override\n    public Uni&lt;Void&gt; registerServiceInstance(String serviceName, Metadata metadata, String ipAddress, int defaultPort) {\n        //do whatever is needed for registering service instance\n        return Uni.createFrom().voidItem();\n    }\n}\n</code></pre> <p>This implementation is simplistic. Typically, instead of creating a service instance with values from the configuration, you would connect to a service discovery backend, look for the service and build the list of service instance accordingly. That\u2019s why the method returns a <code>Uni</code>. Most of the time, the lookup is a remote operation.</p> <p>As you can see, the <code>AcmeConfiguration</code> class gives access to the configuration attribute.</p>"},{"location":"service-registration/custom-service-registration/#using-your-service-registrar","title":"Using your service registrar","text":"<p>In the project using it, don\u2019t forget to add the dependency on the module providing your implementation. Then, in the configuration, just add:</p> stork standalonestork in quarkus <pre><code>stork.my-service.service-registrar.type=acme\nstork.my-service.service-registrar.host=localhost\nstork.my-service.service-registrar.port=1234\n</code></pre> <pre><code>quarkus.stork.my-service.service-registrar.type=acme\nquarkus.stork.my-service.service-registrar.host=localhost\nquarkus.stork.my-service.service-registrar.port=1234\n</code></pre> <p>Then, Stork will use your implementation to register the service instances using the <code>my-service</code> backend.</p>"},{"location":"service-registration/eureka/","title":"Eureka Service Discovery","text":"<p>Eureka is a RESTful service that is primarily used in the AWS cloud for the purpose of discovery, load balancing, and failover of middle-tier servers.</p> <p>This page explains how Stork can use Eureka to handle the service registration.</p>"},{"location":"service-registration/eureka/#dependency","title":"Dependency","text":"<p>First, you need to add the Stork Eureka Service Registration provider:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-service-registration-eureka&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"service-registration/eureka/#service-registration-configuration","title":"Service registration configuration","text":"<p>For each service that should register the service instances in Eureka, configure the service registrar <code>type</code>:</p> stork standalone <pre><code>stork.my-service.service-registrar.type=eureka\nstork.my-service.service-registrar.eureka-host=localhost\nstork.my-service.service-registrar.eureka-port=8761\n</code></pre> stork in quarkus <pre><code>quarkus.stork.my-service.service-registrar.type=eureka\nquarkus.stork.my-service.service-registrar.eureka-host=localhost\nquarkus.stork.my-service.service-registrar.eureka-port=8761\n</code></pre> <p>Eureka service registrar is configured with the following parameters:</p> Attribute Mandatory Default Value Description <code>eureka-host</code> No <code>localhost</code> The Eureka host. <code>eureka-port</code> No <code>8761</code> The Eureka port. <code>eureka-context-path</code> No <code>/</code> The Eureka server root context path. <code>eureka-trust-all</code> No <code>false</code> Enable/Disable the TLS certificate verification <code>eureka-tls</code> No <code>false</code> Use TLS to connect to the Eureka server"},{"location":"service-registration/overview/","title":"Overview","text":""},{"location":"service-registration/overview/#service-registration-in-smallrye-stork","title":"Service Registration in SmallRye Stork","text":"<p>Service registration is the process by which services announce their availability to a central registry, allowing other services to discover and communicate with them.  In SmallRye Stork, service registration is automated and integrated with supported registries like Consul.  This ensures that services can dynamically join and leave the network.</p>"},{"location":"service-registration/overview/#key-features","title":"Key Features:","text":"<ul> <li>Automatic Registration: For Quarkus applications, SmallRye Stork automatically registers it with the configured service registry (e.g., Consul).</li> </ul> <p>IMPORTANT Public IP address needs to be provided. Smallrye Stork will fail if the service IP address is not provided during registration.</p>"},{"location":"service-registration/overview/#supported-registries","title":"Supported Registries:","text":"<p>Currently, Smallrye Stork provides seamless integration with Consul, Eureka and a Static registry. This integration simplifies the management of dynamic environments where services are frequently added or removed.</p>"},{"location":"service-registration/overview/#custom-registration","title":"Custom Registration:","text":"<p>In addition to the default mechanisms, SmallRye Stork allows you to implement custom service registration strategies, providing flexibility for different infrastructures or custom service discovery needs.</p> <p>In the following sections you can have more details about each specific implementation.</p>"},{"location":"service-registration/static-list/","title":"Static List Service Registration","text":"<p>Stork provides the ability to register services using Static list as backend.</p>"},{"location":"service-registration/static-list/#dependency","title":"Dependency","text":"<p>To use the <code>static</code> service registrar, first add the appropriate Service Registration provider dependency to your project:</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;io.smallrye.stork&lt;/groupId&gt;\n    &lt;artifactId&gt;stork-service-registration-static-list&lt;/artifactId&gt;\n    &lt;version&gt;2.7.3&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>"},{"location":"service-registration/static-list/#service-registration-configuration","title":"Service registration configuration","text":"<p>For each service that should register the service instances in a static list, configure the service registrar <code>type</code>:</p> stork standalone <pre><code>stork.my-service.service-registrar.type=static\n</code></pre> stork in quarkus <pre><code>quarkus.stork.my-service.service-registrar.type=static\n</code></pre> <p>Static service registrar is configured with the following parameters:</p> Attribute Mandatory Default Value Description <code>address-list</code> Yes A comma-separated list of addresses (host:port). The default port is 80."}]}